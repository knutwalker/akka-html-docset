


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Camel &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Exo:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Networking" href="index-network.html" />
    <link rel="next" title="Utilities" href="index-utilities.html" />
    <link rel="prev" title="ZeroMQ" href="zeromq.html" />
    <!--Google Analytics-->
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-21117439-1']);
      _gaq.push(['_setDomainName', 'akka.io']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })()
    </script>

  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img src="../_static/logo-small.png" /></a>
        </div>    
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://akka.io/faq">FAQ</a></li>
          <li><a href="http://typesafe.com/stack/downloads/akka">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>           
          <li><a href="http://typesafe.com/products/typesafe-subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Camel</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">           
              <li>
                 <span class="divider">|</span> <a href="index-utilities.html">Utilities</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../index.html">Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="zeromq.html">ZeroMQ</a> <span class="divider">|</span>
              </li>
              <li>
                Version 2.2.3
              </li>
            </ul>
          </div>
        </div>
        <div class="row">
          <div class="span9">
            <div id="cse">Loading</div>
          </div><div class="span9">
            
  <div class="section" id="camel">
<span id="camel-scala"></span><h1>Camel</h1>
<div class="section" id="introduction">
<h2>Introduction</h2>
<p>The akka-camel module allows Untyped Actors to receive
and send messages over a great variety of protocols and APIs.
In addition to the native Scala and Java actor API, actors can now exchange messages with other systems over large number
of protocols and APIs such as HTTP, SOAP, TCP, FTP, SMTP or JMS, to mention a
few. At the moment, approximately 80 protocols and APIs are supported.</p>
<div class="section" id="apache-camel">
<h3>Apache Camel</h3>
<p>The akka-camel module is based on <a class="reference external" href="http://camel.apache.org/">Apache Camel</a>, a powerful and light-weight
integration framework for the JVM. For an introduction to Apache Camel you may
want to read this <a class="reference external" href="http://architects.dzone.com/articles/apache-camel-integration">Apache Camel article</a>. Camel comes with a
large number of <a class="reference external" href="http://camel.apache.org/components.html">components</a> that provide bindings to different protocols and
APIs. The <a class="reference external" href="http://code.google.com/p/camel-extra/">camel-extra</a> project provides further components.</p>
</div>
<div class="section" id="consumer">
<h3>Consumer</h3>
<p>Usage of Camel's integration components in Akka is essentially a
one-liner. Here's an example.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.camel.</span><span class="o">{</span> <span class="nc">CamelMessage</span><span class="o">,</span> <span class="nc">Consumer</span> <span class="o">}</span>

<span class="k">class</span> <span class="nc">MyEndpoint</span> <span class="k">extends</span> <span class="nc">Consumer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">endpointUri</span> <span class="k">=</span> <span class="s">&quot;mina2:tcp://localhost:6200?textline=true&quot;</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">CamelMessage</span> <span class="k">⇒</span> <span class="o">{</span> <span class="kt">/*</span> <span class="kt">...</span> <span class="kt">*/</span> <span class="o">}</span>
    <span class="kt">case</span> <span class="k">_</span>                 <span class="k">⇒</span> <span class="o">{</span> <span class="kt">/*</span> <span class="kt">...</span> <span class="kt">*/</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// start and expose actor via tcp</span>
<span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">ActorSystem</span><span class="o">,</span> <span class="nc">Props</span> <span class="o">}</span>

<span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;some-system&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">mina</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">MyEndpoint</span><span class="o">])</span>
</pre></div>
</div>
<p>The above example exposes an actor over a TCP endpoint via Apache
Camel's <a class="reference external" href="http://camel.apache.org/mina.html">Mina component</a>. The actor implements the endpointUri method to define
an endpoint from which it can receive messages. After starting the actor, TCP
clients can immediately send messages to and receive responses from that
actor. If the message exchange should go over HTTP (via Camel's <a class="reference external" href="http://camel.apache.org/jetty.html">Jetty
component</a>), only the actor's endpointUri method must be changed.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.camel.</span><span class="o">{</span> <span class="nc">CamelMessage</span><span class="o">,</span> <span class="nc">Consumer</span> <span class="o">}</span>

<span class="k">class</span> <span class="nc">MyEndpoint</span> <span class="k">extends</span> <span class="nc">Consumer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">endpointUri</span> <span class="k">=</span> <span class="s">&quot;jetty:http://localhost:8877/example&quot;</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">CamelMessage</span> <span class="k">⇒</span> <span class="o">{</span> <span class="kt">/*</span> <span class="kt">...</span> <span class="kt">*/</span> <span class="o">}</span>
    <span class="kt">case</span> <span class="k">_</span>                 <span class="k">⇒</span> <span class="o">{</span> <span class="kt">/*</span> <span class="kt">...</span> <span class="kt">*/</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="producer">
<h3>Producer</h3>
<p>Actors can also trigger message exchanges with external systems i.e. produce to
Camel endpoints.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.camel.</span><span class="o">{</span> <span class="nc">Producer</span><span class="o">,</span> <span class="nc">Oneway</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">ActorSystem</span><span class="o">,</span> <span class="nc">Props</span> <span class="o">}</span>

<span class="k">class</span> <span class="nc">Orders</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">Producer</span> <span class="k">with</span> <span class="nc">Oneway</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">endpointUri</span> <span class="k">=</span> <span class="s">&quot;jms:queue:Orders&quot;</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">sys</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;some-system&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">orders</span> <span class="k">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Orders</span><span class="o">])</span>

<span class="n">orders</span> <span class="o">!</span> <span class="o">&lt;</span><span class="n">order</span> <span class="n">amount</span><span class="o">=</span><span class="s">&quot;100&quot;</span> <span class="n">currency</span><span class="o">=</span><span class="s">&quot;PLN&quot;</span> <span class="n">itemId</span><span class="o">=</span><span class="s">&quot;12345&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
<p>In the above example, any message sent to this actor will be sent to
the JMS queue <tt class="docutils literal"><span class="pre">orders</span></tt>. Producer actors may choose from the same set of Camel
components as Consumer actors do.</p>
</div>
<div class="section" id="camelmessage">
<h3>CamelMessage</h3>
<p>The number of Camel components is constantly increasing. The akka-camel module
can support these in a plug-and-play manner. Just add them to your application's
classpath, define a component-specific endpoint URI and use it to exchange
messages over the component-specific protocols or APIs. This is possible because
Camel components bind protocol-specific message formats to a Camel-specific
<a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/Message.java">normalized message format</a>. The normalized message format hides
protocol-specific details from Akka and makes it therefore very easy to support
a large number of protocols through a uniform Camel component interface. The
akka-camel module further converts mutable Camel messages into immutable
representations which are used by Consumer and Producer actors for pattern
matching, transformation, serialization or storage. In the above example of the Orders Producer,
the XML message is put in the body of a newly created Camel Message with an empty set of headers.
You can also create a CamelMessage yourself with the appropriate body and headers as you see fit.</p>
</div>
<div class="section" id="camelextension">
<h3>CamelExtension</h3>
<p>The akka-camel module is implemented as an Akka Extension, the <tt class="docutils literal"><span class="pre">CamelExtension</span></tt> object.
Extensions will only be loaded once per <tt class="docutils literal"><span class="pre">ActorSystem</span></tt>, which will be managed by Akka.
The <tt class="docutils literal"><span class="pre">CamelExtension</span></tt> object provides access to the <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/Camel.scala">Camel</a> trait.
The <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/Camel.scala">Camel</a> trait in turn provides access to two important Apache Camel objects, the <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a> and the <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/ProducerTemplate.java">ProducerTemplate</a>.
Below you can see how you can get access to these Apache Camel objects.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;some-system&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">camel</span> <span class="k">=</span> <span class="nc">CamelExtension</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">camelContext</span> <span class="k">=</span> <span class="n">camel</span><span class="o">.</span><span class="n">context</span>
<span class="k">val</span> <span class="n">producerTemplate</span> <span class="k">=</span> <span class="n">camel</span><span class="o">.</span><span class="n">template</span>
</pre></div>
</div>
<p>One <tt class="docutils literal"><span class="pre">CamelExtension</span></tt> is only loaded once for every one <tt class="docutils literal"><span class="pre">ActorSystem</span></tt>, which makes it safe to call the <tt class="docutils literal"><span class="pre">CamelExtension</span></tt> at any point in your code to get to the
Apache Camel objects associated with it. There is one <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a> and one <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/ProducerTemplate.java">ProducerTemplate</a> for every one <tt class="docutils literal"><span class="pre">ActorSystem</span></tt> that uses a <tt class="docutils literal"><span class="pre">CamelExtension</span></tt>.
Below an example on how to add the ActiveMQ component to the <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a>, which is required when you would like to use the ActiveMQ component.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// import org.apache.activemq.camel.component.ActiveMQComponent</span>
<span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;some-system&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">camel</span> <span class="k">=</span> <span class="nc">CamelExtension</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">camelContext</span> <span class="k">=</span> <span class="n">camel</span><span class="o">.</span><span class="n">context</span>
<span class="c1">// camelContext.addComponent(&quot;activemq&quot;, ActiveMQComponent.activeMQComponent(</span>
<span class="c1">//   &quot;vm://localhost?broker.persistent=false&quot;))</span>
</pre></div>
</div>
<p>The <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a> joins the lifecycle of the <tt class="docutils literal"><span class="pre">ActorSystem</span></tt> and <tt class="docutils literal"><span class="pre">CamelExtension</span></tt> it is associated with; the <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a> is started when
the <tt class="docutils literal"><span class="pre">CamelExtension</span></tt> is created, and it is shut down when the associated <tt class="docutils literal"><span class="pre">ActorSystem</span></tt> is shut down. The same is true for the <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/ProducerTemplate.java">ProducerTemplate</a>.</p>
<p>The <tt class="docutils literal"><span class="pre">CamelExtension</span></tt> is used by both <cite>Producer</cite> and <cite>Consumer</cite> actors to interact with Apache Camel internally.
You can access the <tt class="docutils literal"><span class="pre">CamelExtension</span></tt> inside a <cite>Producer</cite> or a <cite>Consumer</cite> using the <tt class="docutils literal"><span class="pre">camel</span></tt> definition, or get straight at the <cite>CamelContext</cite> using the <tt class="docutils literal"><span class="pre">camelContext</span></tt> definition.
Actors are created and started asynchronously. When a <cite>Consumer</cite> actor is created, the <cite>Consumer</cite> is published at its Camel endpoint (more precisely, the route is added to the <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a> from the <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/Endpoint.java">Endpoint</a> to the actor).
When a <cite>Producer</cite> actor is created, a <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java">SendProcessor</a> and <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/Endpoint.java">Endpoint</a> are created so that the Producer can send messages to it.
Publication is done asynchronously; setting up an endpoint may still be in progress after you have
requested the actor to be created. Some Camel components can take a while to startup, and in some cases you might want to know when the endpoints are activated and ready to be used.
The <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/Camel.scala">Camel</a> trait allows you to find out when the endpoint is activated or deactivated.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.camel.</span><span class="o">{</span> <span class="nc">CamelMessage</span><span class="o">,</span> <span class="nc">Consumer</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">class</span> <span class="nc">MyEndpoint</span> <span class="k">extends</span> <span class="nc">Consumer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">endpointUri</span> <span class="k">=</span> <span class="s">&quot;mina2:tcp://localhost:6200?textline=true&quot;</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">CamelMessage</span> <span class="k">⇒</span> <span class="o">{</span> <span class="kt">/*</span> <span class="kt">...</span> <span class="kt">*/</span> <span class="o">}</span>
    <span class="kt">case</span> <span class="k">_</span>                 <span class="k">⇒</span> <span class="o">{</span> <span class="kt">/*</span> <span class="kt">...</span> <span class="kt">*/</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;some-system&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">camel</span> <span class="k">=</span> <span class="nc">CamelExtension</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">actorRef</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">MyEndpoint</span><span class="o">])</span>
<span class="c1">// get a future reference to the activation of the endpoint of the Consumer Actor</span>
<span class="k">val</span> <span class="n">activationFuture</span> <span class="k">=</span> <span class="n">camel</span><span class="o">.</span><span class="n">activationFutureFor</span><span class="o">(</span><span class="n">actorRef</span><span class="o">)(</span><span class="n">timeout</span> <span class="k">=</span> <span class="mi">10</span> <span class="n">seconds</span><span class="o">,</span>
  <span class="n">executor</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">)</span>
</pre></div>
</div>
<p>The above code shows that you can get a <tt class="docutils literal"><span class="pre">Future</span></tt> to the activation of the route from the endpoint to the actor, or you can wait in a blocking fashion on the activation of the route.
An <tt class="docutils literal"><span class="pre">ActivationTimeoutException</span></tt> is thrown if the endpoint could not be activated within the specified timeout. Deactivation works in a similar fashion:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">system</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">actorRef</span><span class="o">)</span>
<span class="c1">// get a future reference to the deactivation of the endpoint of the Consumer Actor</span>
<span class="k">val</span> <span class="n">deactivationFuture</span> <span class="k">=</span> <span class="n">camel</span><span class="o">.</span><span class="n">deactivationFutureFor</span><span class="o">(</span><span class="n">actorRef</span><span class="o">)(</span><span class="n">timeout</span> <span class="k">=</span> <span class="mi">10</span> <span class="n">seconds</span><span class="o">,</span>
  <span class="n">executor</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">)</span>
</pre></div>
</div>
<p>Deactivation of a Consumer or a Producer actor happens when the actor is terminated. For a Consumer, the route to the actor is stopped. For a Producer, the <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java">SendProcessor</a> is stopped.
A <tt class="docutils literal"><span class="pre">DeActivationTimeoutException</span></tt> is thrown if the associated camel objects could not be deactivated within the specified timeout.</p>
</div>
</div>
<div class="section" id="consumer-actors">
<h2>Consumer Actors</h2>
<p>For objects to receive messages, they must mixin the <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/Consumer.scala">Consumer</a>
trait. For example, the following actor class (Consumer1) implements the
endpointUri method, which is declared in the Consumer trait, in order to receive
messages from the <tt class="docutils literal"><span class="pre">file:data/input/actor</span></tt> Camel endpoint.</p>
<div class="highlight-scala"><pre>import akka.camel.{ CamelMessage, Consumer }

class Consumer1 extends Consumer {
  def endpointUri = "file:data/input/actor"

  def receive = {
    case msg: CamelMessage ⇒ println("received %s" format msg.bodyAs[String])
  }
}
</pre>
</div>
<p>Whenever a file is put into the data/input/actor directory, its content is
picked up by the Camel <a class="reference external" href="http://camel.apache.org/file2.html">file component</a> and sent as message to the
actor. Messages consumed by actors from Camel endpoints are of type
<a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/CamelMessage.scala">CamelMessage</a>. These are immutable representations of Camel messages.</p>
<p>Here's another example that sets the endpointUri to
<tt class="docutils literal"><span class="pre">jetty:http://localhost:8877/camel/default</span></tt>. It causes Camel's <a class="reference external" href="http://camel.apache.org/jetty.html">Jetty
component</a> to start an embedded <a class="reference external" href="http://www.eclipse.org/jetty/">Jetty</a> server, accepting HTTP connections
from localhost on port 8877.</p>
<div class="highlight-scala"><pre>import akka.camel.{ CamelMessage, Consumer }

class Consumer2 extends Consumer {
  def endpointUri = "jetty:http://localhost:8877/camel/default"

  def receive = {
    case msg: CamelMessage ⇒ sender ! ("Hello %s" format msg.bodyAs[String])
  }
}
</pre>
</div>
<p>After starting the actor, clients can send messages to that actor by POSTing to
<tt class="docutils literal"><span class="pre">http://localhost:8877/camel/default</span></tt>. The actor sends a response by using the
sender <cite>!</cite> method. For returning a message body and headers to the HTTP
client the response type should be <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/CamelMessage.scala">CamelMessage</a>. For any other response type, a
new CamelMessage object is created by akka-camel with the actor response as message
body.</p>
<div class="section" id="delivery-acknowledgements">
<span id="camel-acknowledgements"></span><h3>Delivery acknowledgements</h3>
<p>With in-out message exchanges, clients usually know that a message exchange is
done when they receive a reply from a consumer actor. The reply message can be a
CamelMessage (or any object which is then internally converted to a CamelMessage) on
success, and a Failure message on failure.</p>
<p>With in-only message exchanges, by default, an exchange is done when a message
is added to the consumer actor's mailbox. Any failure or exception that occurs
during processing of that message by the consumer actor cannot be reported back
to the endpoint in this case. To allow consumer actors to positively or
negatively acknowledge the receipt of a message from an in-only message
exchange, they need to override the <tt class="docutils literal"><span class="pre">autoAck</span></tt> method to return false.
In this case, consumer actors must reply either with a
special akka.camel.Ack message (positive acknowledgement) or a akka.actor.Status.Failure (negative
acknowledgement).</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.camel.</span><span class="o">{</span> <span class="nc">CamelMessage</span><span class="o">,</span> <span class="nc">Consumer</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.camel.Ack</span>
<span class="k">import</span> <span class="nn">akka.actor.Status.Failure</span>

<span class="k">class</span> <span class="nc">Consumer3</span> <span class="k">extends</span> <span class="nc">Consumer</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">autoAck</span> <span class="k">=</span> <span class="kc">false</span>

  <span class="k">def</span> <span class="n">endpointUri</span> <span class="k">=</span> <span class="s">&quot;jms:queue:test&quot;</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">CamelMessage</span> <span class="k">⇒</span>
      <span class="kt">sender</span> <span class="kt">!</span> <span class="kt">Ack</span>
      <span class="c1">// on success</span>
      <span class="c1">// ..</span>
      <span class="k">val</span> <span class="n">someException</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;e1&quot;</span><span class="o">)</span>
      <span class="c1">// on failure</span>
      <span class="n">sender</span> <span class="o">!</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">someException</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="consumer-timeout">
<span id="camel-timeout"></span><h3>Consumer timeout</h3>
<p>Camel Exchanges (and their corresponding endpoints) that support two-way communications need to wait for a response from
an actor before returning it to the initiating client.
For some endpoint types, timeout values can be defined in an endpoint-specific
way which is described in the documentation of the individual <a class="reference external" href="http://camel.apache.org/components.html">Camel
components</a>. Another option is to configure timeouts on the level of consumer actors.</p>
<p>Two-way communications between a Camel endpoint and an actor are
initiated by sending the request message to the actor with the <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-actor/src/main/scala/akka/pattern/AskSupport.scala">ask</a> pattern
and the actor replies to the endpoint when the response is ready. The ask request to the actor can timeout, which will
result in the <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/Exchange.java">Exchange</a> failing with a TimeoutException set on the failure of the <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/Exchange.java">Exchange</a>.
The timeout on the consumer actor can be overridden with the <tt class="docutils literal"><span class="pre">replyTimeout</span></tt>, as shown below.</p>
<div class="highlight-scala"><pre>import akka.camel.{ CamelMessage, Consumer }
import scala.concurrent.duration._

class Consumer4 extends Consumer {
  def endpointUri = "jetty:http://localhost:8877/camel/default"
  override def replyTimeout = 500 millis
  def receive = {
    case msg: CamelMessage ⇒ sender ! ("Hello %s" format msg.bodyAs[String])
  }
}
</pre>
</div>
</div>
</div>
<div class="section" id="producer-actors">
<h2>Producer Actors</h2>
<p>For sending messages to Camel endpoints, actors need to mixin the <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a> trait and implement the endpointUri method.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">Props</span><span class="o">,</span> <span class="nc">ActorSystem</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.camel.</span><span class="o">{</span> <span class="nc">Producer</span><span class="o">,</span> <span class="nc">CamelMessage</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.util.Timeout</span>

<span class="k">class</span> <span class="nc">Producer1</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">Producer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">endpointUri</span> <span class="k">=</span> <span class="s">&quot;http://localhost:8080/news&quot;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Producer1 inherits a default implementation of the receive method from the
Producer trait. To customize a producer actor's default behavior you must override the <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a>.transformResponse and
<a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a>.transformOutgoingMessage methods. This is explained later in more detail.
Producer Actors cannot override the default <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a>.receive method.</p>
<p>Any message sent to a <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a> actor will be sent to
the associated Camel endpoint, in the above example to
<tt class="docutils literal"><span class="pre">http://localhost:8080/news</span></tt>. The <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a> always sends messages asynchronously. Response messages (if supported by the
configured endpoint) will, by default, be returned to the original sender. The
following example uses the ask pattern to send a message to a
Producer actor and waits for a response.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.pattern.ask</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">timeout</span> <span class="k">=</span> <span class="nc">Timeout</span><span class="o">(</span><span class="mi">10</span> <span class="n">seconds</span><span class="o">)</span>

<span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;some-system&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">producer</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Producer1</span><span class="o">])</span>
<span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="n">producer</span><span class="o">.</span><span class="n">ask</span><span class="o">(</span><span class="s">&quot;some request&quot;</span><span class="o">).</span><span class="n">mapTo</span><span class="o">[</span><span class="kt">CamelMessage</span><span class="o">]</span>
</pre></div>
</div>
<p>The future contains the response CamelMessage, or an <tt class="docutils literal"><span class="pre">AkkaCamelException</span></tt> when an error occurred, which contains the headers of the response.</p>
<div class="section" id="custom-processing">
<span id="camel-custom-processing-scala"></span><h3>Custom Processing</h3>
<p>Instead of replying to the initial sender, producer actors can implement custom
response processing by overriding the routeResponse method. In the following example, the response
message is forwarded to a target actor instead of being replied to the original
sender.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">Actor</span><span class="o">,</span> <span class="nc">ActorRef</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.camel.</span><span class="o">{</span> <span class="nc">Producer</span><span class="o">,</span> <span class="nc">CamelMessage</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">Props</span><span class="o">,</span> <span class="nc">ActorSystem</span> <span class="o">}</span>

<span class="k">class</span> <span class="nc">ResponseReceiver</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">CamelMessage</span> <span class="k">⇒</span>
    <span class="kt">//</span> <span class="kt">do</span> <span class="kt">something</span> <span class="kt">with</span> <span class="kt">the</span> <span class="kt">forwarded</span> <span class="kt">response</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Forwarder</span><span class="o">(</span><span class="n">uri</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">target</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">Producer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">endpointUri</span> <span class="k">=</span> <span class="n">uri</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">routeResponse</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="o">{</span> <span class="n">target</span> <span class="n">forward</span> <span class="n">msg</span> <span class="o">}</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;some-system&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">receiver</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">ResponseReceiver</span><span class="o">])</span>
<span class="k">val</span> <span class="n">forwardResponse</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span>
  <span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">Forwarder</span><span class="o">],</span> <span class="k">this</span><span class="o">,</span> <span class="s">&quot;http://localhost:8080/news/akka&quot;</span><span class="o">,</span> <span class="n">receiver</span><span class="o">))</span>
<span class="c1">// the Forwarder sends out a request to the web page and forwards the response to</span>
<span class="c1">// the ResponseReceiver</span>
<span class="n">forwardResponse</span> <span class="o">!</span> <span class="s">&quot;some request&quot;</span>
</pre></div>
</div>
<p>Before producing messages to endpoints, producer actors can pre-process them by
overriding the <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a>.transformOutgoingMessage method.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.camel.</span><span class="o">{</span> <span class="nc">Producer</span><span class="o">,</span> <span class="nc">CamelMessage</span> <span class="o">}</span>

<span class="k">class</span> <span class="nc">Transformer</span><span class="o">(</span><span class="n">uri</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">Producer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">endpointUri</span> <span class="k">=</span> <span class="n">uri</span>

  <span class="k">def</span> <span class="n">upperCase</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">CamelMessage</span><span class="o">)</span> <span class="k">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">mapBody</span> <span class="o">{</span>
    <span class="n">body</span><span class="k">:</span> <span class="kt">String</span> <span class="k">⇒</span> <span class="kt">body.toUpperCase</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">transformOutgoingMessage</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">msg</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">CamelMessage</span> <span class="k">⇒</span> <span class="kt">upperCase</span><span class="o">(</span><span class="kt">msg</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="producer-configuration-options">
<h3>Producer configuration options</h3>
<p>The interaction of producer actors with Camel endpoints can be configured to be
one-way or two-way (by initiating in-only or in-out message exchanges,
respectively). By default, the producer initiates an in-out message exchange
with the endpoint. For initiating an in-only exchange, producer actors have to override the oneway method to return true.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">Actor</span><span class="o">,</span> <span class="nc">Props</span><span class="o">,</span> <span class="nc">ActorSystem</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.camel.Producer</span>

<span class="k">class</span> <span class="nc">OnewaySender</span><span class="o">(</span><span class="n">uri</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">Producer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">endpointUri</span> <span class="k">=</span> <span class="n">uri</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">oneway</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;some-system&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">producer</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">OnewaySender</span><span class="o">],</span> <span class="k">this</span><span class="o">,</span> <span class="s">&quot;activemq:FOO.BAR&quot;</span><span class="o">))</span>
<span class="n">producer</span> <span class="o">!</span> <span class="s">&quot;Some message&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="message-correlation">
<h3>Message correlation</h3>
<p>To correlate request with response messages, applications can set the
<cite>Message.MessageExchangeId</cite> message header.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.camel.</span><span class="o">{</span> <span class="nc">Producer</span><span class="o">,</span> <span class="nc">CamelMessage</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">Props</span><span class="o">,</span> <span class="nc">ActorSystem</span> <span class="o">}</span>

<span class="k">class</span> <span class="nc">Producer2</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">Producer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">endpointUri</span> <span class="k">=</span> <span class="s">&quot;activemq:FOO.BAR&quot;</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;some-system&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">producer</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Producer2</span><span class="o">])</span>

<span class="n">producer</span> <span class="o">!</span> <span class="nc">CamelMessage</span><span class="o">(</span><span class="s">&quot;bar&quot;</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="nc">CamelMessage</span><span class="o">.</span><span class="nc">MessageExchangeId</span> <span class="o">-&gt;</span> <span class="s">&quot;123&quot;</span><span class="o">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>ProducerTemplate</h3>
<p>The <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a> trait is a very
convenient way for actors to produce messages to Camel endpoints. Actors may also use a Camel <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/ProducerTemplate.java">ProducerTemplate</a> for producing
messages to endpoints.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span> <span class="k">⇒</span>
      <span class="k">val</span> <span class="n">template</span> <span class="k">=</span> <span class="nc">CamelExtension</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">).</span><span class="n">template</span>
      <span class="n">template</span><span class="o">.</span><span class="n">sendBody</span><span class="o">(</span><span class="s">&quot;direct:news&quot;</span><span class="o">,</span> <span class="n">msg</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>For initiating a a two-way message exchange, one of the
<tt class="docutils literal"><span class="pre">ProducerTemplate.request*</span></tt> methods must be used.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span> <span class="k">⇒</span>
      <span class="k">val</span> <span class="n">template</span> <span class="k">=</span> <span class="nc">CamelExtension</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">).</span><span class="n">template</span>
      <span class="n">sender</span> <span class="o">!</span> <span class="n">template</span><span class="o">.</span><span class="n">requestBody</span><span class="o">(</span><span class="s">&quot;direct:news&quot;</span><span class="o">,</span> <span class="n">msg</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="asynchronous-routing">
<span id="camel-asynchronous-routing"></span><h2>Asynchronous routing</h2>
<p>In-out message exchanges between endpoints and actors are
designed to be asynchronous. This is the case for both, consumer and producer
actors.</p>
<ul class="simple">
<li>A consumer endpoint sends request messages to its consumer actor using the <tt class="docutils literal"><span class="pre">!</span></tt>
(tell) operator and the actor returns responses with <tt class="docutils literal"><span class="pre">sender</span> <span class="pre">!</span></tt> once they are
ready.</li>
<li>A producer actor sends request messages to its endpoint using Camel's
asynchronous routing engine. Asynchronous responses are wrapped and added to the
producer actor's mailbox for later processing. By default, response messages are
returned to the initial sender but this can be overridden by Producer
implementations (see also description of the <tt class="docutils literal"><span class="pre">routeResponse</span></tt> method
in <a class="reference internal" href="camel.html#camel-custom-processing-scala"><em>Custom Processing</em></a>).</li>
</ul>
<p>However, asynchronous two-way message exchanges, without allocating a thread for
the full duration of exchange, cannot be generically supported by Camel's
asynchronous routing engine alone. This must be supported by the individual
<a class="reference external" href="http://camel.apache.org/components.html">Camel components</a> (from which endpoints are created) as well. They must be
able to suspend any work started for request processing (thereby freeing threads
to do other work) and resume processing when the response is ready. This is
currently the case for a <a class="reference external" href="http://camel.apache.org/asynchronous-routing-engine.html">subset of components</a> such as the <a class="reference external" href="http://camel.apache.org/jetty.html">Jetty component</a>.
All other Camel components can still be used, of course, but they will cause
allocation of a thread for the duration of an in-out message exchange. There's
also a <a class="reference internal" href="camel.html#camel-async-example"><em>Asynchronous routing and transformation example</em></a> that implements both, an asynchronous
consumer and an asynchronous producer, with the jetty component.</p>
<p>If the used Camel component is blocking it might be necessary to use a separate
<a class="reference internal" href="dispatchers.html#dispatchers-scala"><em>dispatcher</em></a> for the producer. The Camel processor is
invoked by a child actor of the producer and the dispatcher can be defined in
the deployment section of the configuration. For example, if your producer actor
has path <tt class="docutils literal"><span class="pre">/user/integration/output</span></tt> the dispatcher of the child actor can be
defined with:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">deployment</span> <span class="o">{</span>
  <span class="o">/</span><span class="n">integration</span><span class="o">/</span><span class="n">output</span><span class="cm">/* {</span>
<span class="cm">    dispatcher = my-dispatcher</span>
<span class="cm">  }</span>
<span class="cm">}</span>
</pre></div>
</div>
</div>
<div class="section" id="custom-camel-routes">
<h2>Custom Camel routes</h2>
<p>In all the examples so far, routes to consumer actors have been automatically
constructed by akka-camel, when the actor was started. Although the default
route construction templates, used by akka-camel internally, are sufficient for
most use cases, some applications may require more specialized routes to actors.
The akka-camel module provides two mechanisms for customizing routes to actors,
which will be explained in this section. These are:</p>
<ul class="simple">
<li>Usage of <a class="reference internal" href="camel.html#id12"><em>Akka Camel components</em></a> to access actors.
Any Camel route can use these components to access Akka actors.</li>
<li><a class="reference internal" href="camel.html#camel-intercepting-route-construction"><em>Intercepting route construction</em></a> to actors.
This option gives you the ability to change routes that have already been added to Camel.
Consumer actors have a hook into the route definition process which can be used to change the route.</li>
</ul>
<div class="section" id="akka-camel-components">
<span id="id12"></span><h3>Akka Camel components</h3>
<p>Akka actors can be accessed from Camel routes using the <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/internal/component/ActorComponent.scala">actor</a> Camel component. This component can be used to
access any Akka actor (not only consumer actors) from Camel routes, as described in the following sections.</p>
</div>
<div class="section" id="access-to-actors">
<span id="id13"></span><h3>Access to actors</h3>
<p>To access actors from custom Camel routes, the <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-camel/src/main/scala/akka/camel/internal/component/ActorComponent.scala">actor</a> Camel
component should be used. It fully supports Camel's <a class="reference external" href="http://camel.apache.org/asynchronous-routing-engine.html">asynchronous routing
engine</a>.</p>
<p>This component accepts the following endpoint URI format:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">[&lt;actor-path&gt;]?&lt;options&gt;</span></tt></li>
</ul>
<p>where <tt class="docutils literal"><span class="pre">&lt;actor-path&gt;</span></tt> is the <tt class="docutils literal"><span class="pre">ActorPath</span></tt> to the actor. The <tt class="docutils literal"><span class="pre">&lt;options&gt;</span></tt> are
name-value pairs separated by <tt class="docutils literal"><span class="pre">&amp;</span></tt> (i.e. <tt class="docutils literal"><span class="pre">name1=value1&amp;name2=value2&amp;...</span></tt>).</p>
<div class="section" id="uri-options">
<h4>URI options</h4>
<p>The following URI options are supported:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="13%" />
<col width="12%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>replyTimeout</td>
<td>Duration</td>
<td>false</td>
<td><p class="first">The reply timeout, specified in the same
way that you use the duration in akka,
for instance <tt class="docutils literal"><span class="pre">10</span> <span class="pre">seconds</span></tt> except that
in the url it is handy to use a +
between the amount and the unit, like
for example <tt class="docutils literal"><span class="pre">200+millis</span></tt></p>
<p class="last">See also <a class="reference internal" href="camel.html#camel-timeout"><em>Consumer timeout</em></a>.</p>
</td>
</tr>
<tr class="row-odd"><td>autoAck</td>
<td>Boolean</td>
<td>true</td>
<td><p class="first">If set to true, in-only message exchanges
are auto-acknowledged when the message is
added to the actor's mailbox. If set to
false, actors must acknowledge the
receipt of the message.</p>
<p class="last">See also <a class="reference internal" href="camel.html#camel-acknowledgements"><em>Delivery acknowledgements</em></a>.</p>
</td>
</tr>
</tbody>
</table>
<p>Here's an actor endpoint URI example containing an actor path:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">://</span><span class="n">some</span><span class="o">-</span><span class="n">system</span><span class="o">/</span><span class="n">user</span><span class="o">/</span><span class="n">myconsumer</span><span class="o">?</span><span class="n">autoAck</span><span class="o">=</span><span class="kc">false</span><span class="o">&amp;</span><span class="n">replyTimeout</span><span class="o">=</span><span class="mi">100</span><span class="o">+</span><span class="n">millis</span>
</pre></div>
</div>
<p>In the following example, a custom route to an actor is created, using the
actor's path. the akka camel package contains an implicit <tt class="docutils literal"><span class="pre">toActorRouteDefinition</span></tt> that allows for a route to
reference an <tt class="docutils literal"><span class="pre">ActorRef</span></tt> directly as shown in the below example, The route starts from a <a class="reference external" href="http://www.eclipse.org/jetty/">Jetty</a> endpoint and
ends at the target actor.</p>
<div class="highlight-scala"><pre>import akka.actor.{ Props, ActorSystem, Actor, ActorRef }
import akka.camel.{ CamelMessage, CamelExtension }
import org.apache.camel.builder.RouteBuilder
import akka.camel._
class Responder extends Actor {
  def receive = {
    case msg: CamelMessage ⇒
      sender ! (msg.mapBody {
        body: String ⇒ "received %s" format body
      })
  }
}

class CustomRouteBuilder(system: ActorSystem, responder: ActorRef)
  extends RouteBuilder {
  def configure {
    from("jetty:http://localhost:8877/camel/custom").to(responder)
  }
}
val system = ActorSystem("some-system")
val camel = CamelExtension(system)
val responder = system.actorOf(Props[Responder], name = "TestResponder")
camel.context.addRoutes(new CustomRouteBuilder(system, responder))
</pre>
</div>
<p>When a message is received on the jetty endpoint, it is routed to the Responder actor, which in return replies back to the client of
the HTTP request.</p>
</div>
</div>
<div class="section" id="intercepting-route-construction">
<span id="camel-intercepting-route-construction"></span><h3>Intercepting route construction</h3>
<p>The previous section, <a class="reference internal" href="camel.html#id12"><em>Akka Camel components</em></a>, explained how to setup a route to an actor manually.
It was the application's responsibility to define the route and add it to the current CamelContext.
This section explains a more convenient way to define custom routes: akka-camel is still setting up the routes to consumer actors (and adds these routes to the current CamelContext) but applications can define extensions to these routes.
Extensions can be defined with Camel's <a class="reference external" href="http://camel.apache.org/dsl.html">Java DSL</a> or <a class="reference external" href="http://camel.apache.org/scala-dsl.html">Scala DSL</a>.
For example, an extension could be a custom error handler that redelivers messages from an endpoint to an actor's bounded mailbox when the mailbox was full.</p>
<p>The following examples demonstrate how to extend a route to a consumer actor for
handling exceptions thrown by that actor.</p>
<div class="highlight-scala"><pre>import akka.camel.Consumer

import org.apache.camel.builder.Builder
import org.apache.camel.model.RouteDefinition

class ErrorThrowingConsumer(override val endpointUri: String) extends Consumer {
  def receive = {
    case msg: CamelMessage ⇒ throw new Exception("error: %s" format msg.body)
  }
  override def onRouteDefinition = (rd) ⇒ rd.onException(classOf[Exception]).
    handled(true).transform(Builder.exceptionMessage).end

  final override def preRestart(reason: Throwable, message: Option[Any]) {
    sender ! Failure(reason)
  }
}
</pre>
</div>
<p>The above ErrorThrowingConsumer sends the Failure back to the sender in preRestart
because the Exception that is thrown in the actor would
otherwise just crash the actor, by default the actor would be restarted, and the response would never reach the client of the Consumer.</p>
<p>The akka-camel module creates a RouteDefinition instance by calling
from(endpointUri) on a Camel RouteBuilder (where endpointUri is the endpoint URI
of the consumer actor) and passes that instance as argument to the route
definition handler *). The route definition handler then extends the route and
returns a ProcessorDefinition (in the above example, the ProcessorDefinition
returned by the end method. See the <a class="reference external" href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/model/">org.apache.camel.model</a> package for
details). After executing the route definition handler, akka-camel finally calls
a to(targetActorUri) on the returned ProcessorDefinition to complete the
route to the consumer actor (where targetActorUri is the actor component URI as described in <a class="reference internal" href="camel.html#access-to-actors"><em>Access to actors</em></a>).
If the actor cannot be found, a <cite>ActorNotRegisteredException</cite> is thrown.</p>
<p>*) Before passing the RouteDefinition instance to the route definition handler,
akka-camel may make some further modifications to it.</p>
</div>
</div>
<div class="section" id="examples">
<span id="camel-examples"></span><h2>Examples</h2>
<div class="section" id="asynchronous-routing-and-transformation-example">
<span id="camel-async-example"></span><h3>Asynchronous routing and transformation example</h3>
<p>This example demonstrates how to implement consumer and producer actors that
support <a class="reference internal" href="camel.html#camel-asynchronous-routing"><em>Asynchronous routing</em></a> with their Camel endpoints. The sample
application transforms the content of the Akka homepage, <a class="reference external" href="http://akka.io">http://akka.io</a>, by
replacing every occurrence of <em>Akka</em> with <em>AKKA</em>. To run this example, add
a Boot class that starts the actors. After starting
the <a class="reference internal" href="microkernel.html#microkernel-scala"><em>Microkernel</em></a>, direct the browser to <a class="reference external" href="http://localhost:8875">http://localhost:8875</a> and the
transformed Akka homepage should be displayed. Please note that this example
will probably not work if you're behind an HTTP proxy.</p>
<p>The following figure gives an overview how the example actors interact with
external systems and with each other. A browser sends a GET request to
<a class="reference external" href="http://localhost:8875">http://localhost:8875</a> which is the published endpoint of the <tt class="docutils literal"><span class="pre">HttpConsumer</span></tt>
actor. The <tt class="docutils literal"><span class="pre">HttpConsumer</span></tt> actor forwards the requests to the <tt class="docutils literal"><span class="pre">HttpProducer</span></tt>
actor which retrieves the Akka homepage from <a class="reference external" href="http://akka.io">http://akka.io</a>. The retrieved HTML
is then forwarded to the <tt class="docutils literal"><span class="pre">HttpTransformer</span></tt> actor which replaces all occurrences
of <em>Akka</em> with <em>AKKA</em>. The transformation result is sent back the HttpConsumer
which finally returns it to the browser.</p>
<img alt="../_images/camel-async-interact1.png" src="../_images/camel-async-interact1.png" />
<p>Implementing the example actor classes and wiring them together is rather easy
as shown in the following snippet.</p>
<div class="highlight-scala"><pre>import org.apache.camel.Exchange
import akka.actor.{ Actor, ActorRef, Props, ActorSystem }
import akka.camel.{ Producer, CamelMessage, Consumer }
import akka.actor.Status.Failure

class HttpConsumer(producer: ActorRef) extends Consumer {
  def endpointUri = "jetty:http://0.0.0.0:8875/"

  def receive = {
    case msg ⇒ producer forward msg
  }
}

class HttpProducer(transformer: ActorRef) extends Actor with Producer {
  def endpointUri = "jetty://http://akka.io/?bridgeEndpoint=true"

  override def transformOutgoingMessage(msg: Any) = msg match {
    case msg: CamelMessage ⇒ msg.copy(headers = msg.headers ++
      msg.headers(Set(Exchange.HTTP_PATH)))
  }

  override def routeResponse(msg: Any) { transformer forward msg }
}

class HttpTransformer extends Actor {
  def receive = {
    case msg: CamelMessage ⇒
      sender ! (msg.mapBody { body: Array[Byte] ⇒
        new String(body).replaceAll("Akka ", "AKKA ")
      })
    case msg: Failure ⇒ sender ! msg
  }
}

// Create the actors. this can be done in a Boot class so you can
// run the example in the MicroKernel. Just add the three lines below
// to your boot class.
val system = ActorSystem("some-system")
val httpTransformer = system.actorOf(Props[HttpTransformer])
val httpProducer = system.actorOf(Props(classOf[HttpProducer], httpTransformer))
val httpConsumer = system.actorOf(Props(classOf[HttpConsumer], httpProducer))
</pre>
</div>
<p>The <a class="reference external" href="http://camel.apache.org/jetty.html">jetty endpoints</a> of HttpConsumer and HttpProducer support asynchronous
in-out message exchanges and do not allocate threads for the full duration of
the exchange. This is achieved by using <a class="reference external" href="http://wiki.eclipse.org/Jetty/Feature/Continuations">Jetty continuations</a> on the
consumer-side and by using <a class="reference external" href="http://wiki.eclipse.org/Jetty/Tutorial/HttpClient">Jetty's asynchronous HTTP client</a> on the producer
side. The following high-level sequence diagram illustrates that.</p>
<img alt="../_images/camel-async-sequence1.png" src="../_images/camel-async-sequence1.png" />
</div>
<div class="section" id="custom-camel-route-example">
<h3>Custom Camel route example</h3>
<p>This section also demonstrates the combined usage of a <tt class="docutils literal"><span class="pre">Producer</span></tt> and a
<tt class="docutils literal"><span class="pre">Consumer</span></tt> actor as well as the inclusion of a custom Camel route. The
following figure gives an overview.</p>
<img alt="../_images/camel-custom-route1.png" src="../_images/camel-custom-route1.png" />
<ul class="simple">
<li>A consumer actor receives a message from an HTTP client</li>
<li>It forwards the message to another actor that transforms the message (encloses
the original message into hyphens)</li>
<li>The transformer actor forwards the transformed message to a producer actor</li>
<li>The producer actor sends the message to a custom Camel route beginning at the
<tt class="docutils literal"><span class="pre">direct:welcome</span></tt> endpoint</li>
<li>A processor (transformer) in the custom Camel route prepends &quot;Welcome&quot; to the
original message and creates a result message</li>
<li>The producer actor sends the result back to the consumer actor which returns
it to the HTTP client</li>
</ul>
<p>The consumer, transformer and
producer actor implementations are as follows.</p>
<div class="highlight-scala"><pre>import akka.actor.{ Actor, ActorRef, Props, ActorSystem }
import akka.camel.{ CamelMessage, Consumer, Producer, CamelExtension }
import org.apache.camel.builder.RouteBuilder
import org.apache.camel.{ Exchange, Processor }

class Consumer3(transformer: ActorRef) extends Actor with Consumer {
  def endpointUri = "jetty:http://0.0.0.0:8877/camel/welcome"

  def receive = {
    // Forward a string representation of the message body to transformer
    case msg: CamelMessage ⇒ transformer.forward(msg.bodyAs[String])
  }
}

class Transformer(producer: ActorRef) extends Actor {
  def receive = {
    // example: transform message body "foo" to "- foo -" and forward result
    // to producer
    case msg: CamelMessage ⇒
      producer.forward(msg.mapBody((body: String) ⇒ "- %s -" format body))
  }
}

class Producer1 extends Actor with Producer {
  def endpointUri = "direct:welcome"
}

class CustomRouteBuilder extends RouteBuilder {
  def configure {
    from("direct:welcome").process(new Processor() {
      def process(exchange: Exchange) {
        // Create a 'welcome' message from the input message
        exchange.getOut.setBody("Welcome %s" format exchange.getIn.getBody)
      }
    })
  }
}
// the below lines can be added to a Boot class, so that you can run the
// example from a MicroKernel
val system = ActorSystem("some-system")
val producer = system.actorOf(Props[Producer1])
val mediator = system.actorOf(Props(classOf[Transformer], producer))
val consumer = system.actorOf(Props(classOf[Consumer3], mediator))
CamelExtension(system).context.addRoutes(new CustomRouteBuilder)
</pre>
</div>
<p>The producer actor knows where to reply the message to because the consumer and
transformer actors have forwarded the original sender reference as well. The
application configuration and the route starting from direct:welcome are done in the code above.</p>
<p>To run the example, add the lines shown in the example to a Boot class and the start the <a class="reference internal" href="microkernel.html#microkernel-scala"><em>Microkernel</em></a> and POST a message to
<tt class="docutils literal"><span class="pre">http://localhost:8877/camel/welcome</span></tt>.</p>
<div class="highlight-none"><div class="highlight"><pre>curl -H &quot;Content-Type: text/plain&quot; -d &quot;Anke&quot; http://localhost:8877/camel/welcome
</pre></div>
</div>
<p>The response should be:</p>
<div class="highlight-none"><div class="highlight"><pre>Welcome - Anke -
</pre></div>
</div>
</div>
<div class="section" id="quartz-scheduler-example">
<h3>Quartz Scheduler Example</h3>
<p>Here is an example showing how simple is to implement a cron-style scheduler by
using the Camel Quartz component in Akka.</p>
<p>The following example creates a &quot;timer&quot; actor which fires a message every 2
seconds:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">ActorSystem</span><span class="o">,</span> <span class="nc">Props</span> <span class="o">}</span>

<span class="k">import</span> <span class="nn">akka.camel.</span><span class="o">{</span> <span class="nc">Consumer</span> <span class="o">}</span>

<span class="k">class</span> <span class="nc">MyQuartzActor</span> <span class="k">extends</span> <span class="nc">Consumer</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">endpointUri</span> <span class="k">=</span> <span class="s">&quot;quartz://example?cron=0/2+*+*+*+*+?&quot;</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>

    <span class="k">case</span> <span class="n">msg</span> <span class="k">⇒</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;==============&gt; received %s &quot;</span> <span class="n">format</span> <span class="n">msg</span><span class="o">)</span>

  <span class="o">}</span> <span class="c1">// end receive</span>

<span class="o">}</span> <span class="c1">// end MyQuartzActor</span>

<span class="k">object</span> <span class="nc">MyQuartzActor</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;my-quartz-system&quot;</span><span class="o">)</span>
    <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">MyQuartzActor</span><span class="o">])</span>
  <span class="o">}</span> <span class="c1">// end main</span>

<span class="o">}</span> <span class="c1">// end MyQuartzActor</span>
</pre></div>
</div>
<p>For more information about the Camel Quartz component, see here:
<a class="reference external" href="http://camel.apache.org/quartz.html">http://camel.apache.org/quartz.html</a></p>
</div>
</div>
<div class="section" id="additional-resources">
<h2>Additional Resources</h2>
<p>For an introduction to akka-camel 2, see also the Peter Gabryanczyk's talk <a class="reference external" href="http://skillsmatter.com/podcast/scala/akka-2-x">Migrating akka-camel module to Akka 2.x</a>.</p>
<p>For an introduction to akka-camel 1, see also the <a class="reference external" href="http://www.manning.com/ibsen/appEsample.pdf">Appendix E - Akka and Camel</a>
(pdf) of the book <a class="reference external" href="http://www.manning.com/ibsen/">Camel in Action</a>.</p>
<p>Other, more advanced external articles (for version 1) are:</p>
<ul class="simple">
<li><a class="reference external" href="http://krasserm.blogspot.com/2011/02/akka-consumer-actors-new-features-and.html">Akka Consumer Actors: New Features and Best Practices</a></li>
<li><a class="reference external" href="http://krasserm.blogspot.com/2011/02/akka-producer-actor-new-features-and.html">Akka Producer Actors: New Features and Best Practices</a></li>
</ul>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://akka.io/faq">FAQ</a></li>
      <li><a href="http://typesafe.com/stack/downloads/akka">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>      
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>      
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://typesafe.com/products/typesafe-subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@typesafe.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/watermark.png" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2013 <a href="http://typesafe.com/">Typesafe Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Oct 23, 2013
    </p>          
  </div>
</div>
<script src="http://www.google.com/jsapi" type="text/javascript"></script>
<script type="text/javascript">
    google.load('search', '1', {language : 'en', style : google.loader.themes.MINIMALIST});
    google.setOnLoadCallback(function() {
    var customSearchOptions = {};  var customSearchControl = new google.search.CustomSearchControl(
    '003065520604945464838:izzukx8-qba', customSearchOptions);
    customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
    customSearchControl.draw('cse');
    var path = window.location.pathname.split('/').slice(0,4);
    if(window.location.hostname && path.length >= 4) {
    var site = "site:" + window.location.hostname + path.join('/').toString();
    customSearchControl.setSearchStartingCallback(this, function(c, s, q) { s.setQueryAddition(site); });
    }
    }, true);
</script>
<style type="text/css">
    .gsc-control-cse {
    font-family: Arial, sans-serif;
    border-color: rgb(242, 242, 235);
    background-color: rgb(242, 242, 235);
    }
    .gsc-control-cse .gsc-table-result {
      font-family: Arial, sans-serif;
      display: block;
    }
    input.gsc-input {
    border-color: #BBBBBB;
    }
    input.gsc-search-button {
    border-color: rgb(34, 57, 64);
    background-color: rgb(68, 114, 129);
    color: #FFFFFF;
    }
    .gsc-tabHeader.gsc-tabhInactive {
    border-color: #777777;
    background-color: #777777;
    }
    .gsc-tabHeader.gsc-tabhActive {
    border-color: #333333;
    background-color: #333333;
    }
    .gsc-tabsArea {
    border-color: #333333;
    }
    .gsc-webResult.gsc-result,
    .gsc-results .gsc-imageResult {
      border-color: #666666;
      background-color: #FFFFFF;
      padding: 0.5em 0.5em;
    }
    .gsc-webResult.gsc-result:hover,
    .gsc-imageResult:hover {
      border-color: #AAAAAA;
      background-color: #FFFFFF;
      padding: 0.5em 0.5em;
    }
    .gsc-webResult.gsc-result.gsc-promotion:hover {
    border-color: #AAAAAA;
    background-color: #FFFFFF;
    }
    .gs-webResult.gs-result a.gs-title:link,
    .gs-webResult.gs-result a.gs-title:link b,
    .gs-imageResult a.gs-title:link,
    .gs-imageResult a.gs-title:link b {
    color: #444444;
    }
    .gs-webResult.gs-result a.gs-title:visited,
    .gs-webResult.gs-result a.gs-title:visited b,
    .gs-imageResult a.gs-title:visited,
    .gs-imageResult a.gs-title:visited b {
    color: #444444;
    }
    .gs-webResult.gs-result a.gs-title:hover,
    .gs-webResult.gs-result a.gs-title:hover b,
    .gs-imageResult a.gs-title:hover,
    .gs-imageResult a.gs-title:hover b {
    color: #444444;
    }
    .gs-webResult.gs-result a.gs-title:active,
    .gs-webResult.gs-result a.gs-title:active b,
    .gs-imageResult a.gs-title:active,
    .gs-imageResult a.gs-title:active b {
    color: #777777;
    }
    .gsc-cursor-page {
    color: #444444;
    }
    a.gsc-trailing-more-results:link {
    color: #444444;
    }
    .gs-webResult .gs-snippet,
    .gs-imageResult .gs-snippet,
    .gs-fileFormatType {
    color: #333333;
    }
    .gs-webResult div.gs-visibleUrl,
    .gs-imageResult div.gs-visibleUrl {
    color: #000000;
    }
    .gs-webResult div.gs-visibleUrl-short {
    color: #000000;
    }
    .gs-webResult div.gs-visibleUrl-short {
    display: none;
    }
    .gs-webResult div.gs-visibleUrl-long {
    display: block;
    }
    .gs-promotion div.gs-visibleUrl-short {
    display: none;
    }
    .gs-promotion div.gs-visibleUrl-long {
    display: block;
    }
    .gsc-cursor-box {
    border-color: #FFFFFF;
    }
    .gsc-results .gsc-cursor-box .gsc-cursor-page {
    border-color: #777777;
    background-color: #FFFFFF;
    color: #444444;
    }
    .gsc-results .gsc-cursor-box .gsc-cursor-current-page {
    border-color: #333333;
    background-color: #333333;
    color: #444444;
    }
    .gsc-webResult.gsc-result.gsc-promotion {
    border-color: #CCCCCC;
    background-color: #E6E6E6;
    }
    .gsc-completion-title {
    color: #444444;
    }
    .gsc-completion-snippet {
    color: #333333;
    }
    .gs-promotion a.gs-title:link,
    .gs-promotion a.gs-title:link *,
    .gs-promotion .gs-snippet a:link {
    color: #0000CC;
    }
    .gs-promotion a.gs-title:visited,
    .gs-promotion a.gs-title:visited *,
    .gs-promotion .gs-snippet a:visited {
    color: #0000CC;
    }
    .gs-promotion a.gs-title:hover,
    .gs-promotion a.gs-title:hover *,
    .gs-promotion .gs-snippet a:hover {
    color: #444444;
    }
    .gs-promotion a.gs-title:active,
    .gs-promotion a.gs-title:active *,
    .gs-promotion .gs-snippet a:active {
    color: #00CC00;
    }
    .gs-promotion .gs-snippet,
    .gs-promotion .gs-title .gs-promotion-title-right,
    .gs-promotion .gs-title .gs-promotion-title-right *  {
    color: #333333;
    }
    .gs-promotion .gs-visibleUrl,
    .gs-promotion .gs-visibleUrl-short {
    color: #00CC00;
    }
</style>
<script type="text/javascript">
  $('#toc').toc();
</script>
  

  </body>
</html>