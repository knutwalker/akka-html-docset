


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Cluster Usage &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Exo:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Networking" href="index-network.html" />
    <link rel="next" title="Remoting" href="remoting.html" />
    <link rel="prev" title="Cluster Specification" href="../common/cluster.html" />
    <!--Google Analytics-->
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-21117439-1']);
      _gaq.push(['_setDomainName', 'akka.io']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })()
    </script>

  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img src="../_static/logo-small.png" /></a>
        </div>    
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://akka.io/faq">FAQ</a></li>
          <li><a href="http://typesafe.com/stack/downloads/akka">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>           
          <li><a href="http://typesafe.com/products/typesafe-subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Cluster Usage</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">           
              <li>
                 <span class="divider">|</span> <a href="remoting.html">Remoting</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../index.html">Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="../common/cluster.html">Cluster Specification</a> <span class="divider">|</span>
              </li>
              <li>
                Version 2.2.3
              </li>
            </ul>
          </div>
        </div>
        <div class="row">
          <div class="span9">
            <div id="cse">Loading</div>
          </div><div class="span9">
            
  <div class="section" id="cluster-usage">
<span id="cluster-usage-scala"></span><h1>Cluster Usage</h1>
<p>For introduction to the Akka Cluster concepts please see <a class="reference internal" href="../common/cluster.html#cluster"><em>Cluster Specification</em></a>.</p>
<div class="section" id="preparing-your-project-for-clustering">
<h2>Preparing Your Project for Clustering</h2>
<p>The Akka cluster is a separate jar file. Make sure that you have the following dependency in your project:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-cluster&quot;</span> <span class="o">%</span> <span class="s">&quot;2.2.3&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="a-simple-cluster-example">
<h2>A Simple Cluster Example</h2>
<p>The following small program together with its configuration starts an <tt class="docutils literal"><span class="pre">ActorSystem</span></tt>
with the Cluster enabled. It joins the cluster and logs some membership events.</p>
<p>Try it out:</p>
<ol class="arabic simple">
<li>Add the following <tt class="docutils literal"><span class="pre">application.conf</span></tt> in your project, place it in <tt class="docutils literal"><span class="pre">src/main/resources</span></tt>:</li>
</ol>
<div class="highlight-scala"><pre>akka {
  actor {
    provider = "akka.cluster.ClusterActorRefProvider"
  }
  remote {
    log-remote-lifecycle-events = off
    netty.tcp {
      hostname = "127.0.0.1"
      port = 0
    }
  }

  cluster {
    seed-nodes = [
      "akka.tcp://ClusterSystem@127.0.0.1:2551",
      "akka.tcp://ClusterSystem@127.0.0.1:2552"]

    auto-down = on
  }
}
</pre>
</div>
<p>To enable cluster capabilities in your Akka project you should, at a minimum, add the <a class="reference internal" href="remoting.html#remoting-scala"><em>Remoting</em></a>
settings, but with <tt class="docutils literal"><span class="pre">akka.cluster.ClusterActorRefProvider</span></tt>.
The <tt class="docutils literal"><span class="pre">akka.cluster.seed-nodes</span></tt> should normally also be added to your <tt class="docutils literal"><span class="pre">application.conf</span></tt> file.</p>
<p>The seed nodes are configured contact points for initial, automatic, join of the cluster.</p>
<p>Note that if you are going to start the nodes on different machines you need to specify the
ip-addresses or host names of the machines in <tt class="docutils literal"><span class="pre">application.conf</span></tt> instead of <tt class="docutils literal"><span class="pre">127.0.0.1</span></tt></p>
<ol class="arabic simple" start="2">
<li>Add the following main program to your project, place it in <tt class="docutils literal"><span class="pre">src/main/scala</span></tt>:</li>
</ol>
<div class="highlight-scala"><pre>package sample.cluster.simple

import akka.actor._
import akka.cluster.Cluster
import akka.cluster.ClusterEvent._

object SimpleClusterApp {
  def main(args: Array[String]): Unit = {

    // Override the configuration of the port
    // when specified as program argument
    if (args.nonEmpty) System.setProperty("akka.remote.netty.tcp.port", args(0))

    // Create an Akka system
    val system = ActorSystem("ClusterSystem")
    val clusterListener = system.actorOf(Props[SimpleClusterListener],
      name = "clusterListener")

    Cluster(system).subscribe(clusterListener, classOf[ClusterDomainEvent])
  }
}

class SimpleClusterListener extends Actor with ActorLogging {
  def receive = {
    case state: CurrentClusterState ⇒
      log.info("Current members: {}", state.members.mkString(", "))
    case MemberUp(member) ⇒
      log.info("Member is Up: {}", member.address)
    case UnreachableMember(member) ⇒
      log.info("Member detected as unreachable: {}", member)
    case MemberRemoved(member, previousStatus) ⇒
      log.info("Member is Removed: {} after {}",
        member.address, previousStatus)
    case _: ClusterDomainEvent ⇒ // ignore
  }
}</pre>
</div>
<ol class="arabic" start="3">
<li><p class="first">Start the first seed node. Open a sbt session in one terminal window and run:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">simple</span><span class="o">.</span><span class="nc">SimpleClusterApp</span> <span class="mi">2551</span>
</pre></div>
</div>
</li>
</ol>
<p>2551 corresponds to the port of the first seed-nodes element in the configuration.
In the log output you see that the cluster node has been started and changed status to 'Up'.</p>
<ol class="arabic" start="4">
<li><p class="first">Start the second seed node. Open a sbt session in another terminal window and run:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">simple</span><span class="o">.</span><span class="nc">SimpleClusterApp</span> <span class="mi">2552</span>
</pre></div>
</div>
</li>
</ol>
<p>2552 corresponds to the port of the second seed-nodes element in the configuration.
In the log output you see that the cluster node has been started and joins the other seed node
and becomes a member of the cluster. Its status changed to 'Up'.</p>
<p>Switch over to the first terminal window and see in the log output that the member joined.</p>
<ol class="arabic" start="5">
<li><p class="first">Start another node. Open a sbt session in yet another terminal window and run:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">simple</span><span class="o">.</span><span class="nc">SimpleClusterApp</span>
</pre></div>
</div>
</li>
</ol>
<p>Now you don't need to specify the port number, and it will use a random available port.
It joins one of the configured seed nodes. Look at the log output in the different terminal
windows.</p>
<p>Start even more nodes in the same way, if you like.</p>
<p>6. Shut down one of the nodes by pressing 'ctrl-c' in one of the terminal windows.
The other nodes will detect the failure after a while, which you can see in the log
output in the other terminals.</p>
<p>Look at the source code of the program again. What it does is to create an actor
and register it as subscriber of certain cluster events. It gets notified with
an snapshot event, <tt class="docutils literal"><span class="pre">CurrentClusterState</span></tt> that holds full state information of
the cluster. After that it receives events for changes that happen in the cluster.</p>
</div>
<div class="section" id="joining-to-seed-nodes">
<h2>Joining to Seed Nodes</h2>
<p>You may decide if joining to the cluster should be done manually or automatically
to configured initial contact points, so-called seed nodes. When a new node is started
it sends a message to all seed nodes and then sends join command to the one that
answers first. If no one of the seed nodes replied (might not be started yet)
it retries this procedure until successful or shutdown.</p>
<p>You define the seed nodes in the <a class="reference internal" href="cluster-usage.html#cluster-configuration-scala"><em>Configuration</em></a> file (application.conf):</p>
<div class="highlight-scala"><pre>akka.cluster.seed-nodes = [
  "akka.tcp://ClusterSystem@host1:2552",
  "akka.tcp://ClusterSystem@host2:2552"]</pre>
</div>
<p>This can also be defined as Java system properties when starting the JVM using the following syntax:</p>
<div class="highlight-scala"><pre>-Dakka.cluster.seed-nodes.0=akka.tcp://ClusterSystem@host1:2552
-Dakka.cluster.seed-nodes.1=akka.tcp://ClusterSystem@host2:2552</pre>
</div>
<p>The seed nodes can be started in any order and it is not necessary to have all
seed nodes running, but the node configured as the first element in the <tt class="docutils literal"><span class="pre">seed-nodes</span></tt>
configuration list must be started when initially starting a cluster, otherwise the
other seed-nodes will not become initialized and no other node can join the cluster.
It is quickest to start all configured seed nodes at the same time (order doesn't matter),
otherwise it can take up to the configured <tt class="docutils literal"><span class="pre">seed-node-timeout</span></tt> until the nodes
can join.</p>
<p>Once more than two seed nodes have been started it is no problem to shut down the first
seed node. If the first seed node is restarted it will first try join the other
seed nodes in the existing cluster.</p>
<p>If you don't configure the seed nodes you need to join manually, using <a class="reference internal" href="cluster-usage.html#cluster-jmx-scala"><em>JMX</em></a>
or <a class="reference internal" href="cluster-usage.html#cluster-command-line-scala"><em>Command Line Management</em></a>. You can join to any node in the cluster. It doesn't
have to be configured as a seed node.</p>
<p>Joining can also be performed programatically with <tt class="docutils literal"><span class="pre">Cluster(system).join(address)</span></tt>.</p>
<p>Unsuccessful join attempts are automatically retried after the time period defined in
configuration property <tt class="docutils literal"><span class="pre">retry-unsuccessful-join-after</span></tt>. When using <tt class="docutils literal"><span class="pre">seed-nodes</span></tt> this
means that a new seed node is picked. When joining manually or programatically this means
that the last join request is retried. Retries can be disabled by setting the property to
<tt class="docutils literal"><span class="pre">off</span></tt>.</p>
<p>An actor system can only join a cluster once. Additional attempts will be ignored.
When it has successfully joined it must be restarted to be able to join another
cluster or to join the same cluster again. It can use the same host name and port
after the restart, but it must have been removed from the cluster before the join
request is accepted.</p>
</div>
<div class="section" id="automatic-vs-manual-downing">
<h2>Automatic vs. Manual Downing</h2>
<p>When a member is considered by the failure detector to be unreachable the
leader is not allowed to perform its duties, such as changing status of
new joining members to 'Up'. The status of the unreachable member must be
changed to 'Down'. This can be performed automatically or manually. By
default it must be done manually, using using <a class="reference internal" href="cluster-usage.html#cluster-jmx-scala"><em>JMX</em></a> or
<a class="reference internal" href="cluster-usage.html#cluster-command-line-scala"><em>Command Line Management</em></a>.</p>
<p>It can also be performed programatically with <tt class="docutils literal"><span class="pre">Cluster(system).down(address)</span></tt>.</p>
<p>You can enable automatic downing with configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">auto</span><span class="o">-</span><span class="n">down</span> <span class="k">=</span> <span class="n">on</span>
</pre></div>
</div>
<p>Be aware of that using auto-down implies that two separate clusters will
automatically be formed in case of network partition. That might be
desired by some applications but not by others.</p>
</div>
<div class="section" id="leaving">
<h2>Leaving</h2>
<p>There are two ways to remove a member from the cluster.</p>
<p>You can just stop the actor system (or the JVM process). It will be detected
as unreachable and removed after the automatic or manual downing as described
above.</p>
<p>A more graceful exit can be performed if you tell the cluster that a node shall leave.
This can be performed using <a class="reference internal" href="cluster-usage.html#cluster-jmx-scala"><em>JMX</em></a> or <a class="reference internal" href="cluster-usage.html#cluster-command-line-scala"><em>Command Line Management</em></a>.
It can also be performed programatically with <tt class="docutils literal"><span class="pre">Cluster(system).leave(address)</span></tt>.</p>
<p>Note that this command can be issued to any member in the cluster, not necessarily the
one that is leaving. The cluster extension, but not the actor system or JVM, of the
leaving member will be shutdown after the leader has changed status of the member to
<cite>Exiting</cite>. Thereafter the member will be removed from the cluster. Normally this is handled
automatically, but in case of network failures during this process it might still be necessary
to set the node’s status to <tt class="docutils literal"><span class="pre">Down</span></tt> in order to complete the removal.</p>
</div>
<div class="section" id="subscribe-to-cluster-events">
<span id="cluster-subscriber-scala"></span><h2>Subscribe to Cluster Events</h2>
<p>You can subscribe to change notifications of the cluster membership by using
<tt class="docutils literal"><span class="pre">Cluster(system).subscribe(subscriber,</span> <span class="pre">to)</span></tt>. A snapshot of the full state,
<tt class="docutils literal"><span class="pre">akka.cluster.ClusterEvent.CurrentClusterState</span></tt>, is sent to the subscriber
as the first event, followed by events for incremental updates.</p>
<p>Note that you may receive an empty <tt class="docutils literal"><span class="pre">CurrentClusterState</span></tt>, containing no members,
if you start the subscription before the initial join procedure has completed.
This is expected behavior. When the node has been accepted in the cluster you will
receive <tt class="docutils literal"><span class="pre">MemberUp</span></tt> for that node, and other nodes.</p>
<p>The events to track the life-cycle of members are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ClusterEvent.MemberUp</span></tt> - A new member has joined the cluster and its status has been changed to <tt class="docutils literal"><span class="pre">Up</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">ClusterEvent.MemberExited</span></tt> - A member is leaving the cluster and its status has been changed to <tt class="docutils literal"><span class="pre">Exiting</span></tt>.
Note that the node might already have been shutdown when this event is published on another node.</li>
<li><tt class="docutils literal"><span class="pre">ClusterEvent.MemberRemoved</span></tt> - Member completely removed from the cluster.</li>
<li><tt class="docutils literal"><span class="pre">ClusterEvent.UnreachableMember</span></tt> - A member is considered as unreachable by the failure detector.</li>
</ul>
<p>There are more types of change events, consult the API documentation
of classes that extends <tt class="docutils literal"><span class="pre">akka.cluster.ClusterEvent.ClusterDomainEvent</span></tt>
for details about the events.</p>
<div class="section" id="worker-dial-in-example">
<h3>Worker Dial-in Example</h3>
<p>Let's take a look at an example that illustrates how workers, here named <em>backend</em>,
can detect and register to new master nodes, here named <em>frontend</em>.</p>
<p>The example application provides a service to transform text. When some text
is sent to one of the frontend services, it will be delegated to one of the
backend workers, which performs the transformation job, and sends the result back to
the original client. New backend nodes, as well as new frontend nodes, can be
added or removed to the cluster dynamically.</p>
<p>In this example the following imports are used:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">language.postfixOps</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorRef</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">akka.actor.Props</span>
<span class="k">import</span> <span class="nn">akka.actor.RootActorPath</span>
<span class="k">import</span> <span class="nn">akka.actor.Terminated</span>
<span class="k">import</span> <span class="nn">akka.cluster.Cluster</span>
<span class="k">import</span> <span class="nn">akka.cluster.ClusterEvent.CurrentClusterState</span>
<span class="k">import</span> <span class="nn">akka.cluster.ClusterEvent.MemberUp</span>
<span class="k">import</span> <span class="nn">akka.cluster.Member</span>
<span class="k">import</span> <span class="nn">akka.cluster.MemberStatus</span>
<span class="k">import</span> <span class="nn">akka.pattern.ask</span>
<span class="k">import</span> <span class="nn">akka.util.Timeout</span>
<span class="k">import</span> <span class="nn">com.typesafe.config.ConfigFactory</span>
</pre></div>
</div>
<p>Messages:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">TransformationJob</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">TransformationResult</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">JobFailed</span><span class="o">(</span><span class="n">reason</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">job</span><span class="k">:</span> <span class="kt">TransformationJob</span><span class="o">)</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">BackendRegistration</span>
</pre></div>
</div>
<p>The backend worker that performs the transformation job:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TransformationBackend</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">cluster</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">)</span>

  <span class="c1">// subscribe to cluster changes, MemberUp</span>
  <span class="c1">// re-subscribe when restart</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">preStart</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">subscribe</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">MemberUp</span><span class="o">])</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">postStop</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">unsubscribe</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">TransformationJob</span><span class="o">(</span><span class="n">text</span><span class="o">)</span> <span class="k">⇒</span> <span class="n">sender</span> <span class="o">!</span> <span class="nc">TransformationResult</span><span class="o">(</span><span class="n">text</span><span class="o">.</span><span class="n">toUpperCase</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">state</span><span class="k">:</span> <span class="kt">CurrentClusterState</span> <span class="k">⇒</span>
      <span class="kt">state.members.filter</span><span class="o">(</span><span class="k">_</span><span class="kt">.status</span> <span class="o">==</span> <span class="nc">MemberStatus</span><span class="o">.</span><span class="nc">Up</span><span class="o">)</span> <span class="n">foreach</span> <span class="n">register</span>
    <span class="k">case</span> <span class="nc">MemberUp</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="k">⇒</span> <span class="n">register</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">register</span><span class="o">(</span><span class="n">member</span><span class="k">:</span> <span class="kt">Member</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="n">hasRole</span><span class="o">(</span><span class="s">&quot;frontend&quot;</span><span class="o">))</span>
      <span class="n">context</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="nc">RootActorPath</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="n">address</span><span class="o">)</span> <span class="o">/</span> <span class="s">&quot;user&quot;</span> <span class="o">/</span> <span class="s">&quot;frontend&quot;</span><span class="o">)</span> <span class="o">!</span>
        <span class="nc">BackendRegistration</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Note that the <tt class="docutils literal"><span class="pre">TransformationBackend</span></tt> actor subscribes to cluster events to detect new,
potential, frontend nodes, and send them a registration message so that they know
that they can use the backend worker.</p>
<p>The frontend that receives user jobs and delegates to one of the registered backend workers:</p>
<div class="highlight-scala"><pre>class TransformationFrontend extends Actor {

  var backends = IndexedSeq.empty[ActorRef]
  var jobCounter = 0

  def receive = {
    case job: TransformationJob if backends.isEmpty ⇒
      sender ! JobFailed("Service unavailable, try again later", job)

    case job: TransformationJob ⇒
      jobCounter += 1
      backends(jobCounter % backends.size) forward job

    case BackendRegistration if !backends.contains(sender) ⇒
      context watch sender
      backends = backends :+ sender

    case Terminated(a) ⇒
      backends = backends.filterNot(_ == a)
  }
}
</pre>
</div>
<p>Note that the <tt class="docutils literal"><span class="pre">TransformationFrontend</span></tt> actor watch the registered backend
to be able to remove it from its list of availble backend workers.
Death watch uses the cluster failure detector for nodes in the cluster, i.e. it detects
network failures and JVM crashes, in addition to graceful termination of watched
actor.</p>
<p>This example is included in <tt class="docutils literal"><span class="pre">akka-samples/akka-sample-cluster</span></tt>
and you can try by starting nodes in different terminal windows. For example, starting 2
frontend nodes and 3 backend nodes:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">sbt</span>

<span class="n">project</span> <span class="n">akka</span><span class="o">-</span><span class="n">sample</span><span class="o">-</span><span class="n">cluster</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="nc">TransformationFrontend</span> <span class="mi">2551</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="nc">TransformationBackend</span> <span class="mi">2552</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="nc">TransformationBackend</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="nc">TransformationBackend</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="nc">TransformationFrontend</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="node-roles">
<h2>Node Roles</h2>
<p>Not all nodes of a cluster need to perform the same function: there might be one sub-set which runs the web front-end,
one which runs the data access layer and one for the number-crunching. Deployment of actors—for example by cluster-aware
routers—can take node roles into account to achieve this distribution of responsibilities.</p>
<p>The roles of a node is defined in the configuration property named <tt class="docutils literal"><span class="pre">akka.cluster.roles</span></tt>
and it is typically defined in the start script as a system property or environment variable.</p>
<p>The roles of the nodes is part of the membership information in <tt class="docutils literal"><span class="pre">MemberEvent</span></tt> that you can subscribe to.</p>
</div>
<div class="section" id="how-to-startup-when-cluster-size-reached">
<h2>How To Startup when Cluster Size Reached</h2>
<p>A common use case is to start actors after the cluster has been initialized,
members have joined, and the cluster has reached a certain size.</p>
<p>With a configuration option you can define required number of members
before the leader changes member status of 'Joining' members to 'Up'.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">min</span><span class="o">-</span><span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">members</span> <span class="k">=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In a similar way you can define required number of members of a certain role
before the leader changes member status of 'Joining' members to 'Up'.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">role</span> <span class="o">{</span>
  <span class="n">frontend</span><span class="o">.</span><span class="n">min</span><span class="o">-</span><span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">members</span> <span class="k">=</span> <span class="mi">1</span>
  <span class="n">backend</span><span class="o">.</span><span class="n">min</span><span class="o">-</span><span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">members</span> <span class="k">=</span> <span class="mi">2</span>
<span class="o">}</span>
</pre></div>
</div>
<p>You can start the actors in a <tt class="docutils literal"><span class="pre">registerOnMemberUp</span></tt> callback, which will
be invoked when the current member status is changed tp 'Up', i.e. the cluster
has at least the defined number of members.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span> <span class="n">registerOnMemberUp</span> <span class="o">{</span>
  <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">FactorialFrontend</span><span class="o">],</span> <span class="n">upToN</span><span class="o">,</span> <span class="kc">true</span><span class="o">),</span>
    <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;factorialFrontend&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This callback can be used for other things than starting actors.</p>
</div>
<div class="section" id="cluster-singleton-pattern">
<h2>Cluster Singleton Pattern</h2>
<p>For some use cases it is convenient and sometimes also mandatory to ensure that
you have exactly one actor of a certain type running somewhere in the cluster.</p>
<p>This can be implemented by subscribing to member events, but there are several corner
cases to consider. Therefore, this specific use case is made easily accessible by the
<a class="reference internal" href="../contrib/cluster-singleton.html#cluster-singleton"><em>Cluster Singleton Pattern</em></a> in the contrib module. You can use it as is, or adjust to fit
your specific needs.</p>
</div>
<div class="section" id="distributed-publish-subscribe-pattern">
<h2>Distributed Publish Subscribe Pattern</h2>
<p>See <a class="reference internal" href="../contrib/distributed-pub-sub.html#distributed-pub-sub"><em>Distributed Publish Subscribe in Cluster</em></a> in the contrib module.</p>
</div>
<div class="section" id="cluster-client">
<h2>Cluster Client</h2>
<p>See <a class="reference internal" href="../contrib/cluster-client.html#cluster-client"><em>Cluster Client</em></a> in the contrib module.</p>
</div>
<div class="section" id="failure-detector">
<h2>Failure Detector</h2>
<p>The nodes in the cluster monitor each other by sending heartbeats to detect if a node is
unreachable from the rest of the cluster. The heartbeat arrival times is interpreted
by an implementation of
<a class="reference external" href="http://ddg.jaist.ac.jp/pub/HDY+04.pdf">The Phi Accrual Failure Detector</a>.</p>
<p>The suspicion level of failure is given by a value called <em>phi</em>.
The basic idea of the phi failure detector is to express the value of <em>phi</em> on a scale that
is dynamically adjusted to reflect current network conditions.</p>
<p>The value of <em>phi</em> is calculated as:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">phi</span> <span class="k">=</span> <span class="o">-</span><span class="n">log10</span><span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">F</span><span class="o">(</span><span class="n">timeSinceLastHeartbeat</span><span class="o">))</span>
</pre></div>
</div>
<p>where F is the cumulative distribution function of a normal distribution with mean
and standard deviation estimated from historical heartbeat inter-arrival times.</p>
<p>In the <a class="reference internal" href="cluster-usage.html#cluster-configuration-scala"><em>Configuration</em></a> you can adjust the <tt class="docutils literal"><span class="pre">akka.cluster.failure-detector.threshold</span></tt>
to define when a <em>phi</em> value is considered to be a failure.</p>
<p>A low <tt class="docutils literal"><span class="pre">threshold</span></tt> is prone to generate many false positives but ensures
a quick detection in the event of a real crash. Conversely, a high <tt class="docutils literal"><span class="pre">threshold</span></tt>
generates fewer mistakes but needs more time to detect actual crashes. The
default <tt class="docutils literal"><span class="pre">threshold</span></tt> is 8 and is appropriate for most situations. However in
cloud environments, such as Amazon EC2, the value could be increased to 12 in
order to account for network issues that sometimes occur on such platforms.</p>
<p>The following chart illustrates how <em>phi</em> increase with increasing time since the
previous heartbeat.</p>
<img alt="../_images/phi11.png" src="../_images/phi11.png" />
<p>Phi is calculated from the mean and standard deviation of historical
inter arrival times. The previous chart is an example for standard deviation
of 200 ms. If the heartbeats arrive with less deviation the curve becomes steeper,
i.e. it is possible to determine failure more quickly. The curve looks like this for
a standard deviation of 100 ms.</p>
<img alt="../_images/phi21.png" src="../_images/phi21.png" />
<p>To be able to survive sudden abnormalities, such as garbage collection pauses and
transient network failures the failure detector is configured with a margin,
<tt class="docutils literal"><span class="pre">akka.cluster.failure-detector.acceptable-heartbeat-pause</span></tt>. You may want to
adjust the <a class="reference internal" href="cluster-usage.html#cluster-configuration-scala"><em>Configuration</em></a> of this depending on you environment.
This is how the curve looks like for <tt class="docutils literal"><span class="pre">acceptable-heartbeat-pause</span></tt> configured to
3 seconds.</p>
<img alt="../_images/phi31.png" src="../_images/phi31.png" />
<p>Death watch uses the cluster failure detector for nodes in the cluster, i.e. it
generates <tt class="docutils literal"><span class="pre">Terminated</span></tt> message from network failures and JVM crashes, in addition
to graceful termination of watched actor.</p>
<p>If you encounter suspicious false positives when the system is under load you should
define a separate dispatcher for the cluster actors as described in <a class="reference internal" href="cluster-usage.html#cluster-dispatcher-scala"><em>Cluster Dispatcher</em></a>.</p>
</div>
<div class="section" id="cluster-aware-routers">
<span id="cluster-aware-routers-scala"></span><h2>Cluster Aware Routers</h2>
<p>All <a class="reference internal" href="routing.html#routing-scala"><em>routers</em></a> can be made aware of member nodes in the cluster, i.e.
deploying new routees or looking up routees on nodes in the cluster.
When a node becomes unavailable or leaves the cluster the routees of that node are
automatically unregistered from the router. When new nodes join the cluster additional
routees are added to the router, according to the configuration.</p>
<p>There are two distinct types of routers.</p>
<ul class="simple">
<li><strong>Router that lookup existing actors and use them as routees.</strong> The routees can be shared between
routers running on different nodes in the cluster. One example of a use case for this
type of router is a service running on some backend nodes in the cluster and
used by routers running on front-end nodes in the cluster.</li>
<li><strong>Router that creates new routees as child actors and deploy them on remote nodes.</strong>
Each router will have its own routee instances. For example, if you start a router
on 3 nodes in a 10 nodes cluster you will have 30 routee actors in total if the router is
configured to use one inctance per node. The routees created by the the different routers
will not be shared between the routers. One example of a use case for this type of router
is a single master that coordinate jobs and delegates the actual work to routees running
on other nodes in the cluster.</li>
</ul>
<div class="section" id="router-with-lookup-of-routees">
<h3>Router with Lookup of Routees</h3>
<p>When using a router with routees looked up on the cluster member nodes, i.e. the routees
are already running, the configuration for a router looks like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">deployment</span> <span class="o">{</span>
  <span class="o">/</span><span class="n">statsService</span><span class="o">/</span><span class="n">workerRouter</span> <span class="o">{</span>
      <span class="n">router</span> <span class="k">=</span> <span class="n">consistent</span><span class="o">-</span><span class="n">hashing</span>
      <span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">instances</span> <span class="k">=</span> <span class="mi">100</span>
      <span class="n">cluster</span> <span class="o">{</span>
        <span class="n">enabled</span> <span class="k">=</span> <span class="n">on</span>
        <span class="n">routees</span><span class="o">-</span><span class="n">path</span> <span class="k">=</span> <span class="s">&quot;/user/statsWorker&quot;</span>
        <span class="n">allow</span><span class="o">-</span><span class="n">local</span><span class="o">-</span><span class="n">routees</span> <span class="k">=</span> <span class="n">on</span>
        <span class="n">use</span><span class="o">-</span><span class="n">role</span> <span class="k">=</span> <span class="n">compute</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The routee actors should be started as early as possible when starting the actor system, because
the router will try to use them as soon as the member status is changed to 'Up'. If it is not
available at that point it will be removed from the router and it will only re-try when the
cluster members are changed.</p>
</div>
<p>It is the relative actor path defined in <tt class="docutils literal"><span class="pre">routees-path</span></tt> that identify what actor to lookup.
It is possible to limit the lookup of routees to member nodes tagged with a certain role by
specifying <tt class="docutils literal"><span class="pre">use-role</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">nr-of-instances</span></tt> defines total number of routees in the cluster, but there will not be
more than one per node. That routee actor could easily fan out to local children if more parallelism
is needed. Setting <tt class="docutils literal"><span class="pre">nr-of-instances</span></tt> to a high value will result in new routees
added to the router when nodes join the cluster.</p>
<p>The same type of router could also have been defined in code:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.cluster.routing.ClusterRouterConfig</span>
<span class="k">import</span> <span class="nn">akka.cluster.routing.ClusterRouterSettings</span>
<span class="k">import</span> <span class="nn">akka.routing.ConsistentHashingRouter</span>

<span class="k">val</span> <span class="n">workerRouter</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">.</span><span class="n">empty</span><span class="o">.</span><span class="n">withRouter</span><span class="o">(</span>
  <span class="nc">ClusterRouterConfig</span><span class="o">(</span><span class="nc">ConsistentHashingRouter</span><span class="o">(),</span> <span class="nc">ClusterRouterSettings</span><span class="o">(</span>
    <span class="n">totalInstances</span> <span class="k">=</span> <span class="mi">100</span><span class="o">,</span> <span class="n">routeesPath</span> <span class="k">=</span> <span class="s">&quot;/user/statsWorker&quot;</span><span class="o">,</span>
    <span class="n">allowLocalRoutees</span> <span class="k">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">useRole</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="s">&quot;compute&quot;</span><span class="o">)))),</span>
  <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;workerRouter2&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="cluster-usage.html#cluster-configuration-scala"><em>Configuration</em></a> section for further descriptions of the settings.</p>
</div>
<div class="section" id="router-example-with-lookup-of-routees">
<h3>Router Example with Lookup of Routees</h3>
<p>Let's take a look at how to use a cluster aware router with lookup of routees.</p>
<p>The example application provides a service to calculate statistics for a text.
When some text is sent to the service it splits it into words, and delegates the task
to count number of characters in each word to a separate worker, a routee of a router.
The character count for each word is sent back to an aggregator that calculates
the average number of characters per word when all results have been collected.</p>
<p>In this example we use the following imports:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">language.postfixOps</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable</span>
<span class="k">import</span> <span class="nn">scala.concurrent.forkjoin.ThreadLocalRandom</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">com.typesafe.config.ConfigFactory</span>
<span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorLogging</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorRef</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorSelection</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">akka.actor.Address</span>
<span class="k">import</span> <span class="nn">akka.actor.PoisonPill</span>
<span class="k">import</span> <span class="nn">akka.actor.Props</span>
<span class="k">import</span> <span class="nn">akka.actor.ReceiveTimeout</span>
<span class="k">import</span> <span class="nn">akka.actor.RelativeActorPath</span>
<span class="k">import</span> <span class="nn">akka.actor.RootActorPath</span>
<span class="k">import</span> <span class="nn">akka.cluster.Cluster</span>
<span class="k">import</span> <span class="nn">akka.cluster.ClusterEvent._</span>
<span class="k">import</span> <span class="nn">akka.cluster.MemberStatus</span>
<span class="k">import</span> <span class="nn">akka.cluster.Member</span>
<span class="k">import</span> <span class="nn">akka.contrib.pattern.ClusterSingletonManager</span>
<span class="k">import</span> <span class="nn">akka.routing.FromConfig</span>
<span class="k">import</span> <span class="nn">akka.routing.ConsistentHashingRouter.ConsistentHashableEnvelope</span>
</pre></div>
</div>
<p>Messages:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">StatsJob</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">StatsResult</span><span class="o">(</span><span class="n">meanWordLength</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">JobFailed</span><span class="o">(</span><span class="n">reason</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre></div>
</div>
<p>The worker that counts number of characters in each word:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">StatsWorker</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">cache</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">word</span><span class="k">:</span> <span class="kt">String</span> <span class="k">⇒</span>
      <span class="kt">val</span> <span class="kt">length</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">word</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">⇒</span> <span class="n">x</span>
        <span class="k">case</span> <span class="nc">None</span> <span class="k">⇒</span>
          <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">word</span><span class="o">.</span><span class="n">length</span>
          <span class="n">cache</span> <span class="o">+=</span> <span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>
          <span class="n">x</span>
      <span class="o">}</span>

      <span class="n">sender</span> <span class="o">!</span> <span class="n">length</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The service that receives text from users and splits it up into words, delegates to workers and aggregates:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">StatsService</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="c1">// This router is used both with lookup and deploy of routees. If you</span>
  <span class="c1">// have a router with only lookup of routees you can use Props.empty</span>
  <span class="c1">// instead of Props[StatsWorker.class].</span>
  <span class="k">val</span> <span class="n">workerRouter</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">StatsWorker</span><span class="o">].</span><span class="n">withRouter</span><span class="o">(</span><span class="nc">FromConfig</span><span class="o">),</span>
    <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;workerRouter&quot;</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">StatsJob</span><span class="o">(</span><span class="n">text</span><span class="o">)</span> <span class="k">if</span> <span class="n">text</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span> <span class="k">⇒</span>
      <span class="k">val</span> <span class="n">words</span> <span class="k">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">replyTo</span> <span class="k">=</span> <span class="n">sender</span> <span class="c1">// important to not close over sender</span>
      <span class="c1">// create actor that collects replies from workers</span>
      <span class="k">val</span> <span class="n">aggregator</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span>
        <span class="n">classOf</span><span class="o">[</span><span class="kt">StatsAggregator</span><span class="o">],</span> <span class="n">words</span><span class="o">.</span><span class="n">size</span><span class="o">,</span> <span class="n">replyTo</span><span class="o">))</span>
      <span class="n">words</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">word</span> <span class="k">⇒</span>
        <span class="n">workerRouter</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span>
          <span class="nc">ConsistentHashableEnvelope</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">word</span><span class="o">),</span> <span class="n">aggregator</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">StatsAggregator</span><span class="o">(</span><span class="n">expectedResults</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">results</span> <span class="k">=</span> <span class="nc">IndexedSeq</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="n">context</span><span class="o">.</span><span class="n">setReceiveTimeout</span><span class="o">(</span><span class="mi">3</span> <span class="n">seconds</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">wordCount</span><span class="k">:</span> <span class="kt">Int</span> <span class="k">⇒</span>
      <span class="kt">results</span> <span class="o">=</span> <span class="n">results</span> <span class="o">:+</span> <span class="n">wordCount</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">results</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">expectedResults</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">meanWordLength</span> <span class="k">=</span> <span class="n">results</span><span class="o">.</span><span class="n">sum</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">/</span> <span class="n">results</span><span class="o">.</span><span class="n">size</span>
        <span class="n">replyTo</span> <span class="o">!</span> <span class="nc">StatsResult</span><span class="o">(</span><span class="n">meanWordLength</span><span class="o">)</span>
        <span class="n">context</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="k">case</span> <span class="nc">ReceiveTimeout</span> <span class="k">⇒</span>
      <span class="n">replyTo</span> <span class="o">!</span> <span class="nc">JobFailed</span><span class="o">(</span><span class="s">&quot;Service unavailable, try again later&quot;</span><span class="o">)</span>
      <span class="n">context</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Note, nothing cluster specific so far, just plain actors.</p>
<p>All nodes start <tt class="docutils literal"><span class="pre">StatsService</span></tt> and <tt class="docutils literal"><span class="pre">StatsWorker</span></tt> actors. Remember, routees are the workers in this case.
The router is configured with <tt class="docutils literal"><span class="pre">routees-path</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">deployment</span> <span class="o">{</span>
  <span class="o">/</span><span class="n">statsService</span><span class="o">/</span><span class="n">workerRouter</span> <span class="o">{</span>
    <span class="n">router</span> <span class="k">=</span> <span class="n">consistent</span><span class="o">-</span><span class="n">hashing</span>
    <span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">instances</span> <span class="k">=</span> <span class="mi">100</span>
    <span class="n">cluster</span> <span class="o">{</span>
      <span class="n">enabled</span> <span class="k">=</span> <span class="n">on</span>
      <span class="n">routees</span><span class="o">-</span><span class="n">path</span> <span class="k">=</span> <span class="s">&quot;/user/statsWorker&quot;</span>
      <span class="n">allow</span><span class="o">-</span><span class="n">local</span><span class="o">-</span><span class="n">routees</span> <span class="k">=</span> <span class="n">on</span>
      <span class="n">use</span><span class="o">-</span><span class="n">role</span> <span class="k">=</span> <span class="n">compute</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This means that user requests can be sent to <tt class="docutils literal"><span class="pre">StatsService</span></tt> on any node and it will use
<tt class="docutils literal"><span class="pre">StatsWorker</span></tt> on all nodes. There can only be one worker per node, but that worker could easily
fan out to local children if more parallelism is needed.</p>
<p>This example is included in <tt class="docutils literal"><span class="pre">akka-samples/akka-sample-cluster</span></tt>
and you can try by starting nodes in different terminal windows. For example, starting 3
service nodes and 1 client:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">sbt</span>

<span class="n">project</span> <span class="n">akka</span><span class="o">-</span><span class="n">sample</span><span class="o">-</span><span class="n">cluster</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="nc">StatsSample</span> <span class="mi">2551</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="nc">StatsSample</span> <span class="mi">2552</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="nc">StatsSampleClient</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="nc">StatsSample</span>
</pre></div>
</div>
</div>
<div class="section" id="router-with-remote-deployed-routees">
<h3>Router with Remote Deployed Routees</h3>
<p>When using a router with routees created and deployed on the cluster member nodes
the configuration for a router looks like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">deployment</span> <span class="o">{</span>
  <span class="o">/</span><span class="n">singleton</span><span class="o">/</span><span class="n">statsService</span><span class="o">/</span><span class="n">workerRouter</span> <span class="o">{</span>
      <span class="n">router</span> <span class="k">=</span> <span class="n">consistent</span><span class="o">-</span><span class="n">hashing</span>
      <span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">instances</span> <span class="k">=</span> <span class="mi">100</span>
      <span class="n">cluster</span> <span class="o">{</span>
        <span class="n">enabled</span> <span class="k">=</span> <span class="n">on</span>
        <span class="n">max</span><span class="o">-</span><span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">instances</span><span class="o">-</span><span class="n">per</span><span class="o">-</span><span class="n">node</span> <span class="k">=</span> <span class="mi">3</span>
        <span class="n">allow</span><span class="o">-</span><span class="n">local</span><span class="o">-</span><span class="n">routees</span> <span class="k">=</span> <span class="n">off</span>
        <span class="n">use</span><span class="o">-</span><span class="n">role</span> <span class="k">=</span> <span class="n">compute</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>It is possible to limit the deployment of routees to member nodes tagged with a certain role by
specifying <tt class="docutils literal"><span class="pre">use-role</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">nr-of-instances</span></tt> defines total number of routees in the cluster, but the number of routees
per node, <tt class="docutils literal"><span class="pre">max-nr-of-instances-per-node</span></tt>, will not be exceeded. Setting <tt class="docutils literal"><span class="pre">nr-of-instances</span></tt>
to a high value will result in creating and deploying additional routees when new nodes join
the cluster.</p>
<p>The same type of router could also have been defined in code:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.cluster.routing.ClusterRouterConfig</span>
<span class="k">import</span> <span class="nn">akka.cluster.routing.ClusterRouterSettings</span>
<span class="k">import</span> <span class="nn">akka.routing.ConsistentHashingRouter</span>

<span class="k">val</span> <span class="n">workerRouter</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">StatsWorker</span><span class="o">].</span><span class="n">withRouter</span><span class="o">(</span>
  <span class="nc">ClusterRouterConfig</span><span class="o">(</span><span class="nc">ConsistentHashingRouter</span><span class="o">(),</span> <span class="nc">ClusterRouterSettings</span><span class="o">(</span>
    <span class="n">totalInstances</span> <span class="k">=</span> <span class="mi">100</span><span class="o">,</span> <span class="n">maxInstancesPerNode</span> <span class="k">=</span> <span class="mi">3</span><span class="o">,</span>
    <span class="n">allowLocalRoutees</span> <span class="k">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">useRole</span> <span class="k">=</span> <span class="nc">None</span><span class="o">))),</span>
  <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;workerRouter3&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="cluster-usage.html#cluster-configuration-scala"><em>Configuration</em></a> section for further descriptions of the settings.</p>
</div>
<div class="section" id="router-example-with-remote-deployed-routees">
<h3>Router Example with Remote Deployed Routees</h3>
<p>Let's take a look at how to use a cluster aware router on single master node that creates
and deploys workers. To keep track of a single master we use the <a class="reference internal" href="../contrib/cluster-singleton.html#cluster-singleton"><em>Cluster Singleton Pattern</em></a>
in the contrib module. The <tt class="docutils literal"><span class="pre">ClusterSingletonManager</span></tt> is started on each node.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">ClusterSingletonManager</span><span class="o">.</span><span class="n">props</span><span class="o">(</span>
  <span class="n">singletonProps</span> <span class="k">=</span> <span class="k">_</span> <span class="k">⇒</span> <span class="nc">Props</span><span class="o">[</span><span class="kt">StatsService</span><span class="o">],</span> <span class="n">singletonName</span> <span class="k">=</span> <span class="s">&quot;statsService&quot;</span><span class="o">,</span>
  <span class="n">terminationMessage</span> <span class="k">=</span> <span class="nc">PoisonPill</span><span class="o">,</span> <span class="n">role</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="s">&quot;compute&quot;</span><span class="o">)),</span>
  <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;singleton&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>We also need an actor on each node that keeps track of where current single master exists and
delegates jobs to the <tt class="docutils literal"><span class="pre">StatsService</span></tt>.</p>
<div class="highlight-scala"><pre>class StatsFacade extends Actor with ActorLogging {
  import context.dispatcher
  val cluster = Cluster(context.system)

  // sort by age, oldest first
  val ageOrdering = Ordering.fromLessThan[Member] { (a, b) ⇒ a.isOlderThan(b) }
  var membersByAge: immutable.SortedSet[Member] = immutable.SortedSet.empty(ageOrdering)

  // subscribe to cluster changes
  // re-subscribe when restart
  override def preStart(): Unit = cluster.subscribe(self, classOf[MemberEvent])
  override def postStop(): Unit = cluster.unsubscribe(self)

  def receive = {
    case job: StatsJob if membersByAge.isEmpty ⇒
      sender ! JobFailed("Service unavailable, try again later")
    case job: StatsJob ⇒
      currentMaster.tell(job, sender)
    case state: CurrentClusterState ⇒
      membersByAge = immutable.SortedSet.empty(ageOrdering) ++ state.members.collect {
        case m if m.hasRole("compute") ⇒ m
      }
    case MemberUp(m)         ⇒ if (m.hasRole("compute")) membersByAge += m
    case MemberRemoved(m, _) ⇒ if (m.hasRole("compute")) membersByAge -= m
    case _: MemberEvent      ⇒ // not interesting
  }

  def currentMaster: ActorSelection =
    context.actorSelection(RootActorPath(membersByAge.head.address) /
      "user" / "singleton" / "statsService")

}
</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">StatsFacade</span></tt> receives text from users and delegates to the current <tt class="docutils literal"><span class="pre">StatsService</span></tt>, the single
master. It listens to cluster events to lookup the <tt class="docutils literal"><span class="pre">StatsService</span></tt> on the oldest node.</p>
<p>All nodes start <tt class="docutils literal"><span class="pre">StatsFacade</span></tt> and the <tt class="docutils literal"><span class="pre">ClusterSingletonManager</span></tt>. The router is now configured like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">deployment</span> <span class="o">{</span>
  <span class="o">/</span><span class="n">singleton</span><span class="o">/</span><span class="n">statsService</span><span class="o">/</span><span class="n">workerRouter</span> <span class="o">{</span>
    <span class="n">router</span> <span class="k">=</span> <span class="n">consistent</span><span class="o">-</span><span class="n">hashing</span>
    <span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">instances</span> <span class="k">=</span> <span class="mi">100</span>
    <span class="n">cluster</span> <span class="o">{</span>
      <span class="n">enabled</span> <span class="k">=</span> <span class="n">on</span>
      <span class="n">max</span><span class="o">-</span><span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">instances</span><span class="o">-</span><span class="n">per</span><span class="o">-</span><span class="n">node</span> <span class="k">=</span> <span class="mi">3</span>
      <span class="n">allow</span><span class="o">-</span><span class="n">local</span><span class="o">-</span><span class="n">routees</span> <span class="k">=</span> <span class="n">off</span>
      <span class="n">use</span><span class="o">-</span><span class="n">role</span> <span class="k">=</span> <span class="n">compute</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This example is included in <tt class="docutils literal"><span class="pre">akka-samples/akka-sample-cluster</span></tt>
and you can try by starting nodes in different terminal windows. For example, starting 3
service nodes and 1 client:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="nc">StatsSampleOneMaster</span> <span class="mi">2551</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="nc">StatsSampleOneMaster</span> <span class="mi">2552</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="nc">StatsSampleOneMasterClient</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="nc">StatsSampleOneMaster</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The above example will be simplified when the cluster handles automatic actor partitioning.</p>
</div>
</div>
</div>
<div class="section" id="cluster-metrics">
<h2>Cluster Metrics</h2>
<p>The member nodes of the cluster collects system health metrics and publishes that to other nodes and to
registered subscribers. This information is primarily used for load-balancing routers.</p>
<div class="section" id="hyperic-sigar">
<h3>Hyperic Sigar</h3>
<p>The built-in metrics is gathered from JMX MBeans, and optionally you can use <a class="reference external" href="http://www.hyperic.com/products/sigar">Hyperic Sigar</a>
for a wider and more accurate range of metrics compared to what can be retrieved from ordinary MBeans.
Sigar is using a native OS library. To enable usage of Sigar you need to add the directory of the native library to
<tt class="docutils literal"><span class="pre">-Djava.libarary.path=&lt;path_of_sigar_libs&gt;</span></tt> add the following dependency:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;org.fusesource&quot;</span> <span class="o">%</span> <span class="s">&quot;sigar&quot;</span> <span class="o">%</span> <span class="s">&quot;1.6.4&quot;</span>
</pre></div>
</div>
<p>Download the native Sigar libraries from <a class="reference external" href="http://repo1.maven.org/maven2/org/fusesource/sigar/1.6.4/">Maven Central</a></p>
</div>
<div class="section" id="adaptive-load-balancing">
<h3>Adaptive Load Balancing</h3>
<p>The <tt class="docutils literal"><span class="pre">AdaptiveLoadBalancingRouter</span></tt> performs load balancing of messages to cluster nodes based on the cluster metrics data.
It uses random selection of routees with probabilities derived from the remaining capacity of the corresponding node.
It can be configured to use a specific MetricsSelector to produce the probabilities, a.k.a. weights:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">heap</span></tt> / <tt class="docutils literal"><span class="pre">HeapMetricsSelector</span></tt> - Used and max JVM heap memory. Weights based on remaining heap capacity; (max - used) / max</li>
<li><tt class="docutils literal"><span class="pre">load</span></tt> / <tt class="docutils literal"><span class="pre">SystemLoadAverageMetricsSelector</span></tt> - System load average for the past 1 minute, corresponding value can be found in <tt class="docutils literal"><span class="pre">top</span></tt> of Linux systems. The system is possibly nearing a bottleneck if the system load average is nearing number of cpus/cores. Weights based on remaining load capacity; 1 - (load / processors)</li>
<li><tt class="docutils literal"><span class="pre">cpu</span></tt> / <tt class="docutils literal"><span class="pre">CpuMetricsSelector</span></tt> - CPU utilization in percentage, sum of User + Sys + Nice + Wait. Weights based on remaining cpu capacity; 1 - utilization</li>
<li><tt class="docutils literal"><span class="pre">mix</span></tt> / <tt class="docutils literal"><span class="pre">MixMetricsSelector</span></tt> - Combines heap, cpu and load. Weights based on mean of remaining capacity of the combined selectors.</li>
<li>Any custom implementation of <tt class="docutils literal"><span class="pre">akka.cluster.routing.MetricsSelector</span></tt></li>
</ul>
<p>The collected metrics values are smoothed with <a class="reference external" href="http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average">exponential weighted moving average</a>. In the <a class="reference internal" href="cluster-usage.html#cluster-configuration-scala"><em>Configuration</em></a> you can adjust how quickly past data is decayed compared to new data.</p>
<p>Let's take a look at this router in action.</p>
<p>In this example the following imports are used:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">scala.annotation.tailrec</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>
<span class="k">import</span> <span class="nn">com.typesafe.config.ConfigFactory</span>
<span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorLogging</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorRef</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">akka.actor.Props</span>
<span class="k">import</span> <span class="nn">akka.pattern.pipe</span>
<span class="k">import</span> <span class="nn">akka.routing.FromConfig</span>
</pre></div>
</div>
<p>The backend worker that performs the factorial calculation:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">FactorialBackend</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">ActorLogging</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">context.dispatcher</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">⇒</span>
      <span class="nc">Future</span><span class="o">(</span><span class="n">factorial</span><span class="o">(</span><span class="n">n</span><span class="o">))</span> <span class="n">map</span> <span class="o">{</span> <span class="n">result</span> <span class="k">⇒</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">result</span><span class="o">)</span> <span class="o">}</span> <span class="n">pipeTo</span> <span class="n">sender</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nd">@tailrec</span> <span class="k">def</span> <span class="n">factorialAcc</span><span class="o">(</span><span class="n">acc</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="n">acc</span>
      <span class="k">else</span> <span class="n">factorialAcc</span><span class="o">(</span><span class="n">acc</span> <span class="o">*</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="n">factorialAcc</span><span class="o">(</span><span class="nc">BigInt</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<p>The frontend that receives user jobs and delegates to the backends via the router:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">FactorialFrontend</span><span class="o">(</span><span class="n">upToN</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repeat</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">ActorLogging</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">backend</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">.</span><span class="n">empty</span><span class="o">.</span><span class="n">withRouter</span><span class="o">(</span><span class="nc">FromConfig</span><span class="o">),</span>
    <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;factorialBackendRouter&quot;</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">preStart</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">sendJobs</span><span class="o">()</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">factorial</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span> <span class="k">⇒</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">upToN</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="o">(</span><span class="s">&quot;{}! = {}&quot;</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">factorial</span><span class="o">)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">repeat</span><span class="o">)</span> <span class="n">sendJobs</span><span class="o">()</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">sendJobs</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Starting batch of factorials up to [{}]&quot;</span><span class="o">,</span> <span class="n">upToN</span><span class="o">)</span>
    <span class="mi">1</span> <span class="n">to</span> <span class="n">upToN</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">backend</span> <span class="o">!</span> <span class="k">_</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>As you can see, the router is defined in the same way as other routers, and in this case it is configured as follows:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">deployment</span> <span class="o">{</span>
  <span class="o">/</span><span class="n">factorialFrontend</span><span class="o">/</span><span class="n">factorialBackendRouter</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">router</span> <span class="k">=</span> <span class="n">adaptive</span>
    <span class="k">#</span> <span class="n">metrics</span><span class="o">-</span><span class="n">selector</span> <span class="k">=</span> <span class="n">heap</span>
    <span class="k">#</span> <span class="n">metrics</span><span class="o">-</span><span class="n">selector</span> <span class="k">=</span> <span class="n">load</span>
    <span class="k">#</span> <span class="n">metrics</span><span class="o">-</span><span class="n">selector</span> <span class="k">=</span> <span class="n">cpu</span>
    <span class="n">metrics</span><span class="o">-</span><span class="n">selector</span> <span class="k">=</span> <span class="n">mix</span>
    <span class="n">nr</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">instances</span> <span class="k">=</span> <span class="mi">100</span>
    <span class="n">cluster</span> <span class="o">{</span>
      <span class="n">enabled</span> <span class="k">=</span> <span class="n">on</span>
      <span class="n">routees</span><span class="o">-</span><span class="n">path</span> <span class="k">=</span> <span class="s">&quot;/user/factorialBackend&quot;</span>
      <span class="n">use</span><span class="o">-</span><span class="n">role</span> <span class="k">=</span> <span class="n">backend</span>
      <span class="n">allow</span><span class="o">-</span><span class="n">local</span><span class="o">-</span><span class="n">routees</span> <span class="k">=</span> <span class="n">off</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>It is only router type <tt class="docutils literal"><span class="pre">adaptive</span></tt> and the <tt class="docutils literal"><span class="pre">metrics-selector</span></tt> that is specific to this router, other things work
in the same way as other routers.</p>
<p>The same type of router could also have been defined in code:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.cluster.routing.ClusterRouterConfig</span>
<span class="k">import</span> <span class="nn">akka.cluster.routing.ClusterRouterSettings</span>
<span class="k">import</span> <span class="nn">akka.cluster.routing.AdaptiveLoadBalancingRouter</span>
<span class="k">import</span> <span class="nn">akka.cluster.routing.HeapMetricsSelector</span>

<span class="k">val</span> <span class="n">backend</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">.</span><span class="n">empty</span><span class="o">.</span><span class="n">withRouter</span><span class="o">(</span>
  <span class="nc">ClusterRouterConfig</span><span class="o">(</span><span class="nc">AdaptiveLoadBalancingRouter</span><span class="o">(</span><span class="nc">HeapMetricsSelector</span><span class="o">),</span>
    <span class="nc">ClusterRouterSettings</span><span class="o">(</span>
      <span class="n">totalInstances</span> <span class="k">=</span> <span class="mi">100</span><span class="o">,</span> <span class="n">routeesPath</span> <span class="k">=</span> <span class="s">&quot;/user/factorialBackend&quot;</span><span class="o">,</span>
      <span class="n">allowLocalRoutees</span> <span class="k">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">useRole</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="s">&quot;backend&quot;</span><span class="o">)))),</span>
  <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;factorialBackendRouter2&quot;</span><span class="o">)</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.cluster.routing.ClusterRouterConfig</span>
<span class="k">import</span> <span class="nn">akka.cluster.routing.ClusterRouterSettings</span>
<span class="k">import</span> <span class="nn">akka.cluster.routing.AdaptiveLoadBalancingRouter</span>
<span class="k">import</span> <span class="nn">akka.cluster.routing.SystemLoadAverageMetricsSelector</span>

<span class="k">val</span> <span class="n">backend</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">FactorialBackend</span><span class="o">].</span><span class="n">withRouter</span><span class="o">(</span>
  <span class="nc">ClusterRouterConfig</span><span class="o">(</span><span class="nc">AdaptiveLoadBalancingRouter</span><span class="o">(</span>
    <span class="nc">SystemLoadAverageMetricsSelector</span><span class="o">),</span> <span class="nc">ClusterRouterSettings</span><span class="o">(</span>
    <span class="n">totalInstances</span> <span class="k">=</span> <span class="mi">100</span><span class="o">,</span> <span class="n">maxInstancesPerNode</span> <span class="k">=</span> <span class="mi">3</span><span class="o">,</span>
    <span class="n">allowLocalRoutees</span> <span class="k">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">useRole</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="s">&quot;backend&quot;</span><span class="o">)))),</span>
  <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;factorialBackendRouter3&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>This example is included in <tt class="docutils literal"><span class="pre">akka-samples/akka-sample-cluster</span></tt>
and you can try by starting nodes in different terminal windows. For example, starting 3 backend nodes and one frontend:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">sbt</span>

<span class="n">project</span> <span class="n">akka</span><span class="o">-</span><span class="n">sample</span><span class="o">-</span><span class="n">cluster</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">factorial</span><span class="o">.</span><span class="nc">FactorialBackend</span> <span class="mi">2551</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">factorial</span><span class="o">.</span><span class="nc">FactorialBackend</span> <span class="mi">2552</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">factorial</span><span class="o">.</span><span class="nc">FactorialBackend</span>

<span class="n">run</span><span class="o">-</span><span class="n">main</span> <span class="n">sample</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">factorial</span><span class="o">.</span><span class="nc">FactorialFrontend</span>
</pre></div>
</div>
<p>Press ctrl-c in the terminal window of the frontend to stop the factorial calculations.</p>
</div>
<div class="section" id="subscribe-to-metrics-events">
<h3>Subscribe to Metrics Events</h3>
<p>It is possible to subscribe to the metrics events directly to implement other functionality.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.cluster.Cluster</span>
<span class="k">import</span> <span class="nn">akka.cluster.ClusterEvent.ClusterMetricsChanged</span>
<span class="k">import</span> <span class="nn">akka.cluster.ClusterEvent.CurrentClusterState</span>
<span class="k">import</span> <span class="nn">akka.cluster.NodeMetrics</span>
<span class="k">import</span> <span class="nn">akka.cluster.StandardMetrics.HeapMemory</span>
<span class="k">import</span> <span class="nn">akka.cluster.StandardMetrics.Cpu</span>

<span class="k">class</span> <span class="nc">MetricsListener</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">ActorLogging</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">selfAddress</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">).</span><span class="n">selfAddress</span>

  <span class="c1">// subscribe to ClusterMetricsChanged</span>
  <span class="c1">// re-subscribe when restart</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">preStart</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nc">Cluster</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">).</span><span class="n">subscribe</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">ClusterMetricsChanged</span><span class="o">])</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">postStop</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nc">Cluster</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">).</span><span class="n">unsubscribe</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ClusterMetricsChanged</span><span class="o">(</span><span class="n">clusterMetrics</span><span class="o">)</span> <span class="k">⇒</span>
      <span class="n">clusterMetrics</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">_</span><span class="o">.</span><span class="n">address</span> <span class="o">==</span> <span class="n">selfAddress</span><span class="o">)</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">nodeMetrics</span> <span class="k">⇒</span>
        <span class="n">logHeap</span><span class="o">(</span><span class="n">nodeMetrics</span><span class="o">)</span>
        <span class="n">logCpu</span><span class="o">(</span><span class="n">nodeMetrics</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="k">case</span> <span class="n">state</span><span class="k">:</span> <span class="kt">CurrentClusterState</span> <span class="k">⇒</span> <span class="kt">//</span> <span class="kt">ignore</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">logHeap</span><span class="o">(</span><span class="n">nodeMetrics</span><span class="k">:</span> <span class="kt">NodeMetrics</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">nodeMetrics</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">HeapMemory</span><span class="o">(</span><span class="n">address</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">,</span> <span class="n">used</span><span class="o">,</span> <span class="n">committed</span><span class="o">,</span> <span class="n">max</span><span class="o">)</span> <span class="k">⇒</span>
      <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Used heap: {} MB&quot;</span><span class="o">,</span> <span class="n">used</span><span class="o">.</span><span class="n">doubleValue</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">/</span> <span class="mi">1024</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">⇒</span> <span class="c1">// no heap info</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">logCpu</span><span class="o">(</span><span class="n">nodeMetrics</span><span class="k">:</span> <span class="kt">NodeMetrics</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">nodeMetrics</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Cpu</span><span class="o">(</span><span class="n">address</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">systemLoadAverage</span><span class="o">),</span> <span class="n">cpuCombined</span><span class="o">,</span> <span class="n">processors</span><span class="o">)</span> <span class="k">⇒</span>
      <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Load: {} ({} processors)&quot;</span><span class="o">,</span> <span class="n">systemLoadAverage</span><span class="o">,</span> <span class="n">processors</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">⇒</span> <span class="c1">// no cpu info</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="custom-metrics-collector">
<h3>Custom Metrics Collector</h3>
<p>You can plug-in your own metrics collector instead of
<tt class="docutils literal"><span class="pre">akka.cluster.SigarMetricsCollector</span></tt> or <tt class="docutils literal"><span class="pre">akka.cluster.JmxMetricsCollector</span></tt>. Look at those two implementations
for inspiration. The implementation class can be defined in the <a class="reference internal" href="cluster-usage.html#cluster-configuration-scala"><em>Configuration</em></a>.</p>
</div>
</div>
<div class="section" id="how-to-test">
<h2>How to Test</h2>
<p><a class="reference internal" href="../dev/multi-node-testing.html#multi-node-testing"><em>Multi Node Testing</em></a> is useful for testing cluster applications.</p>
<p>Set up your project according to the instructions in <a class="reference internal" href="../dev/multi-node-testing.html#multi-node-testing"><em>Multi Node Testing</em></a> and <a class="reference internal" href="../dev/multi-jvm-testing.html#multi-jvm-testing"><em>Multi JVM Testing</em></a>, i.e.
add the <tt class="docutils literal"><span class="pre">sbt-multi-jvm</span></tt> plugin and the dependency to <tt class="docutils literal"><span class="pre">akka-multi-node-testkit</span></tt>.</p>
<p>First, as described in <a class="reference internal" href="../dev/multi-node-testing.html#multi-node-testing"><em>Multi Node Testing</em></a>, we need some scaffolding to configure the <tt class="docutils literal"><span class="pre">MultiNodeSpec</span></tt>.
Define the participating roles and their <a class="reference internal" href="cluster-usage.html#cluster-configuration-scala"><em>Configuration</em></a> in an object extending <tt class="docutils literal"><span class="pre">MultiNodeConfig</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.remote.testkit.MultiNodeConfig</span>
<span class="k">import</span> <span class="nn">com.typesafe.config.ConfigFactory</span>

<span class="k">object</span> <span class="nc">StatsSampleSpecConfig</span> <span class="k">extends</span> <span class="nc">MultiNodeConfig</span> <span class="o">{</span>
  <span class="c1">// register the named roles (nodes) of the test</span>
  <span class="k">val</span> <span class="n">first</span> <span class="k">=</span> <span class="n">role</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">second</span> <span class="k">=</span> <span class="n">role</span><span class="o">(</span><span class="s">&quot;second&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">third</span> <span class="k">=</span> <span class="n">role</span><span class="o">(</span><span class="s">&quot;thrid&quot;</span><span class="o">)</span>

  <span class="c1">// this configuration will be used for all nodes</span>
  <span class="c1">// note that no fixed host names and ports are used</span>
  <span class="n">commonConfig</span><span class="o">(</span><span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">parseString</span><span class="o">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">    akka.actor.provider = &quot;akka.cluster.ClusterActorRefProvider&quot;</span>
<span class="s">    akka.remote.log-remote-lifecycle-events = off</span>
<span class="s">    akka.cluster.roles = [compute]</span>
<span class="s">    # don&#39;t use sigar for tests, native lib not in path</span>
<span class="s">    akka.cluster.metrics.collector-class = akka.cluster.JmxMetricsCollector</span>
<span class="s">     // router lookup config ...</span>
<span class="s">    &quot;&quot;&quot;</span><span class="o">))</span>

<span class="o">}</span>
</pre></div>
</div>
<p>Define one concrete test class for each role/node. These will be instantiated on the different nodes (JVMs). They can be
implemented differently, but often they are the same and extend an abstract test class, as illustrated here.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// need one concrete test class per node</span>
<span class="k">class</span> <span class="nc">StatsSampleSpecMultiJvmNode1</span> <span class="k">extends</span> <span class="nc">StatsSampleSpec</span>
<span class="k">class</span> <span class="nc">StatsSampleSpecMultiJvmNode2</span> <span class="k">extends</span> <span class="nc">StatsSampleSpec</span>
<span class="k">class</span> <span class="nc">StatsSampleSpecMultiJvmNode3</span> <span class="k">extends</span> <span class="nc">StatsSampleSpec</span>
</pre></div>
</div>
<p>Note the naming convention of these classes. The name of the classes must end with <tt class="docutils literal"><span class="pre">MultiJvmNode1</span></tt>, <tt class="docutils literal"><span class="pre">MultiJvmNode2</span></tt>
and so on. It is possible to define another suffix to be used by the <tt class="docutils literal"><span class="pre">sbt-multi-jvm</span></tt>, but the default should be
fine in most cases.</p>
<p>Then the abstract <tt class="docutils literal"><span class="pre">MultiNodeSpec</span></tt>, which takes the <tt class="docutils literal"><span class="pre">MultiNodeConfig</span></tt> as constructor parameter.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">org.scalatest.BeforeAndAfterAll</span>
<span class="k">import</span> <span class="nn">org.scalatest.WordSpec</span>
<span class="k">import</span> <span class="nn">org.scalatest.matchers.MustMatchers</span>
<span class="k">import</span> <span class="nn">akka.remote.testkit.MultiNodeSpec</span>
<span class="k">import</span> <span class="nn">akka.testkit.ImplicitSender</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">StatsSampleSpec</span> <span class="k">extends</span> <span class="nc">MultiNodeSpec</span><span class="o">(</span><span class="nc">StatsSampleSpecConfig</span><span class="o">)</span>
  <span class="k">with</span> <span class="nc">WordSpec</span> <span class="k">with</span> <span class="nc">MustMatchers</span> <span class="k">with</span> <span class="nc">BeforeAndAfterAll</span>
  <span class="k">with</span> <span class="nc">ImplicitSender</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">StatsSampleSpecConfig._</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">initialParticipants</span> <span class="k">=</span> <span class="n">roles</span><span class="o">.</span><span class="n">size</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">beforeAll</span><span class="o">()</span> <span class="k">=</span> <span class="n">multiNodeSpecBeforeAll</span><span class="o">()</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">afterAll</span><span class="o">()</span> <span class="k">=</span> <span class="n">multiNodeSpecAfterAll</span><span class="o">()</span>
</pre></div>
</div>
<p>Most of this can of course be extracted to a separate trait to avoid repeating this in all your tests.</p>
<p>Typically you begin your test by starting up the cluster and let the members join, and create some actors.
That can be done like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;illustrate how to startup cluster&quot;</span> <span class="n">in</span> <span class="n">within</span><span class="o">(</span><span class="mi">15</span> <span class="n">seconds</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">subscribe</span><span class="o">(</span><span class="n">testActor</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">MemberUp</span><span class="o">])</span>
  <span class="n">expectMsgClass</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">CurrentClusterState</span><span class="o">])</span>

  <span class="k">val</span> <span class="n">firstAddress</span> <span class="k">=</span> <span class="n">node</span><span class="o">(</span><span class="n">first</span><span class="o">).</span><span class="n">address</span>
  <span class="k">val</span> <span class="n">secondAddress</span> <span class="k">=</span> <span class="n">node</span><span class="o">(</span><span class="n">second</span><span class="o">).</span><span class="n">address</span>
  <span class="k">val</span> <span class="n">thirdAddress</span> <span class="k">=</span> <span class="n">node</span><span class="o">(</span><span class="n">third</span><span class="o">).</span><span class="n">address</span>

  <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span> <span class="n">join</span> <span class="n">firstAddress</span>

  <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">StatsWorker</span><span class="o">],</span> <span class="s">&quot;statsWorker&quot;</span><span class="o">)</span>
  <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">StatsService</span><span class="o">],</span> <span class="s">&quot;statsService&quot;</span><span class="o">)</span>

  <span class="n">receiveN</span><span class="o">(</span><span class="mi">3</span><span class="o">).</span><span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">MemberUp</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">}.</span><span class="n">toSet</span> <span class="n">must</span> <span class="n">be</span> <span class="o">(</span>
       <span class="nc">Set</span><span class="o">(</span><span class="n">firstAddress</span><span class="o">,</span> <span class="n">secondAddress</span><span class="o">,</span> <span class="n">thirdAddress</span><span class="o">))</span>

  <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">unsubscribe</span><span class="o">(</span><span class="n">testActor</span><span class="o">)</span>

  <span class="n">testConductor</span><span class="o">.</span><span class="n">enter</span><span class="o">(</span><span class="s">&quot;all-up&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>From the test you interact with the cluster using the <tt class="docutils literal"><span class="pre">Cluster</span></tt> extension, e.g. <tt class="docutils literal"><span class="pre">join</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span> <span class="n">join</span> <span class="n">firstAddress</span>
</pre></div>
</div>
<p>Notice how the <cite>testActor</cite> from <a class="reference internal" href="testing.html#akka-testkit"><em>testkit</em></a> is added as <a class="reference internal" href="cluster-usage.html#cluster-subscriber-scala"><em>subscriber</em></a>
to cluster changes and then waiting for certain events, such as in this case all members becoming 'Up'.</p>
<p>The above code was running for all roles (JVMs). <tt class="docutils literal"><span class="pre">runOn</span></tt> is a convenient utility to declare that a certain block
of code should only run for a specific role.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;show usage of the statsService from one node&quot;</span> <span class="n">in</span> <span class="n">within</span><span class="o">(</span><span class="mi">15</span> <span class="n">seconds</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">runOn</span><span class="o">(</span><span class="n">second</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">assertServiceOk</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="n">testConductor</span><span class="o">.</span><span class="n">enter</span><span class="o">(</span><span class="s">&quot;done-2&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">assertServiceOk</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">service</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="n">node</span><span class="o">(</span><span class="n">third</span><span class="o">)</span> <span class="o">/</span> <span class="s">&quot;user&quot;</span> <span class="o">/</span> <span class="s">&quot;statsService&quot;</span><span class="o">)</span>
  <span class="c1">// eventually the service should be ok,</span>
  <span class="c1">// first attempts might fail because worker actors not started yet</span>
  <span class="n">awaitAssert</span> <span class="o">{</span>
    <span class="n">service</span> <span class="o">!</span> <span class="nc">StatsJob</span><span class="o">(</span><span class="s">&quot;this is the text that will be analyzed&quot;</span><span class="o">)</span>
    <span class="n">expectMsgType</span><span class="o">[</span><span class="kt">StatsResult</span><span class="o">](</span><span class="mf">1.</span><span class="n">second</span><span class="o">).</span><span class="n">meanWordLength</span> <span class="n">must</span> <span class="n">be</span><span class="o">(</span>
      <span class="mf">3.875</span> <span class="n">plusOrMinus</span> <span class="mf">0.001</span><span class="o">)</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<p>Once again we take advantage of the facilities in <a class="reference internal" href="testing.html#akka-testkit"><em>testkit</em></a> to verify expected behavior.
Here using <tt class="docutils literal"><span class="pre">testActor</span></tt> as sender (via <tt class="docutils literal"><span class="pre">ImplicitSender</span></tt>) and verifing the reply with <tt class="docutils literal"><span class="pre">expectMsgPF</span></tt>.</p>
<p>In the above code you can see <tt class="docutils literal"><span class="pre">node(third)</span></tt>, which is useful facility to get the root actor reference of
the actor system for a specific role. This can also be used to grab the <tt class="docutils literal"><span class="pre">akka.actor.Address</span></tt> of that node.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">firstAddress</span> <span class="k">=</span> <span class="n">node</span><span class="o">(</span><span class="n">first</span><span class="o">).</span><span class="n">address</span>
<span class="k">val</span> <span class="n">secondAddress</span> <span class="k">=</span> <span class="n">node</span><span class="o">(</span><span class="n">second</span><span class="o">).</span><span class="n">address</span>
<span class="k">val</span> <span class="n">thirdAddress</span> <span class="k">=</span> <span class="n">node</span><span class="o">(</span><span class="n">third</span><span class="o">).</span><span class="n">address</span>
</pre></div>
</div>
</div>
<div class="section" id="jmx">
<span id="cluster-jmx-scala"></span><h2>JMX</h2>
<p>Information and management of the cluster is available as JMX MBeans with the root name <tt class="docutils literal"><span class="pre">akka.Cluster</span></tt>.
The JMX information can be displayed with an ordinary JMX console such as JConsole or JVisualVM.</p>
<p>From JMX you can:</p>
<ul class="simple">
<li>see what members that are part of the cluster</li>
<li>see status of this node</li>
<li>join this node to another node in cluster</li>
<li>mark any node in the cluster as down</li>
<li>tell any node in the cluster to leave</li>
</ul>
<p>Member nodes are identified by their address, in format <cite>akka.&lt;protocol&gt;://&lt;actor-system-name&gt;&#64;&lt;hostname&gt;:&lt;port&gt;</cite>.</p>
</div>
<div class="section" id="command-line-management">
<span id="cluster-command-line-scala"></span><h2>Command Line Management</h2>
<p>The cluster can be managed with the script <cite>bin/akka-cluster</cite> provided in the
Akka distribution.</p>
<p>Run it without parameters to see instructions about how to use the script:</p>
<div class="highlight-scala"><pre>Usage: bin/akka-cluster &lt;node-hostname&gt; &lt;jmx-port&gt; &lt;command&gt; ...

Supported commands are:
           join &lt;node-url&gt; - Sends request a JOIN node with the specified URL
          leave &lt;node-url&gt; - Sends a request for node with URL to LEAVE the cluster
           down &lt;node-url&gt; - Sends a request for marking node with URL as DOWN
             member-status - Asks the member node for its current status
                   members - Asks the cluster for addresses of current members
               unreachable - Asks the cluster for addresses of unreachable members
            cluster-status - Asks the cluster for its current status (member ring,
                             unavailable nodes, meta data etc.)
                    leader - Asks the cluster who the current leader is
              is-singleton - Checks if the cluster is a singleton cluster (single
                             node cluster)
              is-available - Checks if the member node is available
Where the &lt;node-url&gt; should be on the format of
  'akka.&lt;protocol&gt;://&lt;actor-system-name&gt;@&lt;hostname&gt;:&lt;port&gt;'

Examples: bin/akka-cluster localhost 9999 is-available
          bin/akka-cluster localhost 9999 join akka.tcp://MySystem@darkstar:2552
          bin/akka-cluster localhost 9999 cluster-status</pre>
</div>
<p>To be able to use the script you must enable remote monitoring and management when starting the JVMs of the cluster nodes,
as described in <a class="reference external" href="http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html">Monitoring and Management Using JMX Technology</a></p>
<p>Example of system properties to enable remote monitoring and management:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">java</span> <span class="o">-</span><span class="nc">Dcom</span><span class="o">.</span><span class="n">sun</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">jmxremote</span><span class="o">.</span><span class="n">port</span><span class="o">=</span><span class="mi">9999</span> <span class="o">\</span>
<span class="o">-</span><span class="nc">Dcom</span><span class="o">.</span><span class="n">sun</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">jmxremote</span><span class="o">.</span><span class="n">authenticate</span><span class="o">=</span><span class="kc">false</span> <span class="o">\</span>
<span class="o">-</span><span class="nc">Dcom</span><span class="o">.</span><span class="n">sun</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">jmxremote</span><span class="o">.</span><span class="n">ssl</span><span class="o">=</span><span class="kc">false</span>
</pre></div>
</div>
</div>
<div class="section" id="configuration">
<span id="cluster-configuration-scala"></span><h2>Configuration</h2>
<p>There are several configuration properties for the cluster. We refer to the following
reference file for more information:</p>
<div class="highlight-none"><div class="highlight"><pre>######################################
# Akka Cluster Reference Config File #
######################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {

  cluster {
    # Initial contact points of the cluster.
    # The nodes to join automatically at startup.
    # Comma separated full URIs defined by a string on the form of
    # &quot;akka://system@hostname:port&quot;
    # Leave as empty if the node is supposed to be joined manually.
    seed-nodes = []

    # how long to wait for one of the seed nodes to reply to initial join request
    seed-node-timeout = 5s

    # If a join request fails it will be retried after this period.
    # Disable join retry by specifying &quot;off&quot;.
    retry-unsuccessful-join-after = 10s

    # Should the &#39;leader&#39; in the cluster be allowed to automatically mark
    # unreachable nodes as DOWN?
    # Using auto-down implies that two separate clusters will automatically be
    # formed in case of network partition.
    auto-down = off

    # The roles of this member. List of strings, e.g. roles = [&quot;A&quot;, &quot;B&quot;].
    # The roles are part of the membership information and can be used by
    # routers or other services to distribute work to certain member types,
    # e.g. front-end and back-end nodes.
    roles = []

    role {
      # Minimum required number of members of a certain role before the leader
      # changes member status of &#39;Joining&#39; members to &#39;Up&#39;. Typically used together
      # with &#39;Cluster.registerOnMemberUp&#39; to defer some action, such as starting
      # actors, until the cluster has reached a certain size.
      # E.g. to require 2 nodes with role &#39;frontend&#39; and 3 nodes with role &#39;backend&#39;:
      #   frontend.min-nr-of-members = 2
      #   backend.min-nr-of-members = 3
      #&lt;role-name&gt;.min-nr-of-members = 1
    }

    # Minimum required number of members before the leader changes member status
    # of &#39;Joining&#39; members to &#39;Up&#39;. Typically used together with
    # &#39;Cluster.registerOnMemberUp&#39; to defer some action, such as starting actors,
    # until the cluster has reached a certain size.
    min-nr-of-members = 1

    # Enable/disable info level logging of cluster events
    log-info = on

    # Enable or disable JMX MBeans for management of the cluster
    jmx.enabled = on

    # how long should the node wait before starting the periodic tasks
    # maintenance tasks?
    periodic-tasks-initial-delay = 1s

    # how often should the node send out gossip information?
    gossip-interval = 1s

    # how often should the leader perform maintenance tasks?
    leader-actions-interval = 1s

    # how often should the node move nodes, marked as unreachable by the failure
    # detector, out of the membership ring?
    unreachable-nodes-reaper-interval = 1s

    # How often the current internal stats should be published.
    # A value of 0s can be used to always publish the stats, when it happens.
    # Disable with &quot;off&quot;.
    publish-stats-interval = off

    # The id of the dispatcher to use for cluster actors. If not specified
    # default dispatcher is used.
    # If specified you need to define the settings of the actual dispatcher.
    use-dispatcher = &quot;&quot;

    # Gossip to random node with newer or older state information, if any with
    # this probability. Otherwise Gossip to any random live node.
    # Probability value is between 0.0 and 1.0. 0.0 means never, 1.0 means always.
    gossip-different-view-probability = 0.8

    # Settings for the Phi accrual failure detector (http://ddg.jaist.ac.jp/pub/HDY+04.pdf
    # [Hayashibara et al]) used by the cluster subsystem to detect unreachable
    # members.
    failure-detector {

      # FQCN of the failure detector implementation.
      # It must implement akka.remote.FailureDetector and have
      # a public constructor with a com.typesafe.config.Config and
      # akka.actor.EventStream parameter.
      implementation-class = &quot;akka.remote.PhiAccrualFailureDetector&quot;

      # How often keep-alive heartbeat messages should be sent to each connection.
      heartbeat-interval = 1 s

      # Defines the failure detector threshold.
      # A low threshold is prone to generate many wrong suspicions but ensures
      # a quick detection in the event of a real crash. Conversely, a high
      # threshold generates fewer mistakes but needs more time to detect
      # actual crashes.
      threshold = 8.0

      # Number of the samples of inter-heartbeat arrival times to adaptively
      # calculate the failure timeout for connections.
      max-sample-size = 1000

      # Minimum standard deviation to use for the normal distribution in
      # AccrualFailureDetector. Too low standard deviation might result in
      # too much sensitivity for sudden, but normal, deviations in heartbeat
      # inter arrival times.
      min-std-deviation = 100 ms

      # Number of potentially lost/delayed heartbeats that will be
      # accepted before considering it to be an anomaly.
      # This margin is important to be able to survive sudden, occasional,
      # pauses in heartbeat arrivals, due to for example garbage collect or
      # network drop.
      acceptable-heartbeat-pause = 3 s

      # Number of member nodes that each member will send heartbeat messages to,
      # i.e. each node will be monitored by this number of other nodes.
      monitored-by-nr-of-members = 5

      # When a node stops sending heartbeats to another node it will end that
      # with this number of EndHeartbeat messages, which will remove the
      # monitoring from the failure detector.
      nr-of-end-heartbeats = 8

      # When no expected heartbeat message has been received an explicit
      # heartbeat request is sent to the node that should emit heartbeats.
      heartbeat-request {
        # Grace period until an explicit heartbeat request is sent
        grace-period = 10 s

        # After the heartbeat request has been sent the first failure detection
        # will start after this period, even though no heartbeat mesage has
        # been received.
        expected-response-after = 3 s

        # Cleanup of obsolete heartbeat requests
        time-to-live = 60 s
      }
    }

    metrics {
      # Enable or disable metrics collector for load-balancing nodes.
      enabled = on

      # FQCN of the metrics collector implementation.
      # It must implement akka.cluster.MetricsCollector and
      # have public constructor with akka.actor.ActorSystem parameter.
      # The default SigarMetricsCollector uses JMX and Hyperic SIGAR, if SIGAR
      # is on the classpath, otherwise only JMX.
      collector-class = &quot;akka.cluster.SigarMetricsCollector&quot;

      # How often metrics are sampled on a node.
      # Shorter interval will collect the metrics more often.
      collect-interval = 3s

      # How often a node publishes metrics information.
      gossip-interval = 3s

      # How quickly the exponential weighting of past data is decayed compared to
      # new data. Set lower to increase the bias toward newer values.
      # The relevance of each data sample is halved for every passing half-life
      # duration, i.e. after 4 times the half-life, a data sample’s relevance is
      # reduced to 6% of its original relevance. The initial relevance of a data
      # sample is given by 1 – 0.5 ^ (collect-interval / half-life).
      # See http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
      moving-average-half-life = 12s
    }

    # If the tick-duration of the default scheduler is longer than the
    # tick-duration configured here a dedicated scheduler will be used for
    # periodic tasks of the cluster, otherwise the default scheduler is used.
    # See akka.scheduler settings for more details.
    scheduler {
      tick-duration = 33ms
      ticks-per-wheel = 512
    }

  }

  # Default configuration for routers
  actor.deployment.default {
    # MetricsSelector to use
    # - available: &quot;mix&quot;, &quot;heap&quot;, &quot;cpu&quot;, &quot;load&quot;
    # - or: Fully qualified class name of the MetricsSelector class.
    #       The class must extend akka.cluster.routing.MetricsSelector
    #       and have a public constructor with com.typesafe.config.Config
    #       parameter.
    # - default is &quot;mix&quot;
    metrics-selector = mix
  }
  actor.deployment.default.cluster {
    # enable cluster aware router that deploys to nodes in the cluster
    enabled = off

    # Maximum number of routees that will be deployed on each cluster
    # member node.
    # Note that nr-of-instances defines total number of routees, but
    # number of routees per node will not be exceeded, i.e. if you
    # define nr-of-instances = 50 and max-nr-of-instances-per-node = 2
    # it will deploy 2 routees per new member in the cluster, up to
    # 25 members.
    max-nr-of-instances-per-node = 1

    # Defines if routees are allowed to be located on the same node as
    # the head router actor, or only on remote nodes.
    # Useful for master-worker scenario where all routees are remote.
    allow-local-routees = on

    # Actor path of the routees to lookup with actorFor on the member
    # nodes in the cluster. E.g. &quot;/user/myservice&quot;. If this isn&#39;t defined
    # the routees will be deployed instead of looked up.
    # max-nr-of-instances-per-node should not be configured (default value is 1)
    # when routees-path is defined.
    routees-path = &quot;&quot;

    # Use members with specified role, or all members if undefined or empty.
    use-role = &quot;&quot;

  }

  # Protobuf serializer for cluster messages
  actor {
    serializers {
      akka-cluster = &quot;akka.cluster.protobuf.ClusterMessageSerializer&quot;
    }

    serialization-bindings {
      &quot;akka.cluster.ClusterMessage&quot; = akka-cluster
    }
  }

}
</pre></div>
</div>
<div class="section" id="cluster-info-logging">
<h3>Cluster Info Logging</h3>
<p>You can silence the logging of cluster events at info level with configuration property:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">log</span><span class="o">-</span><span class="n">info</span> <span class="k">=</span> <span class="n">off</span>
</pre></div>
</div>
</div>
<div class="section" id="cluster-dispatcher">
<span id="cluster-dispatcher-scala"></span><h3>Cluster Dispatcher</h3>
<p>Under the hood the cluster extension is implemented with actors and it can be necessary
to create a bulkhead for those actors to avoid disturbance from other actors. Especially
the heartbeating actors that is used for failure detection can generate false positives
if they are not given a chance to run at regular intervals.
For this purpose you can define a separate dispatcher to be used for the cluster actors:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">use</span><span class="o">-</span><span class="n">dispatcher</span> <span class="k">=</span> <span class="n">cluster</span><span class="o">-</span><span class="n">dispatcher</span>

<span class="n">cluster</span><span class="o">-</span><span class="n">dispatcher</span> <span class="o">{</span>
  <span class="k">type</span> <span class="o">=</span> <span class="s">&quot;Dispatcher&quot;</span>
  <span class="n">executor</span> <span class="k">=</span> <span class="s">&quot;fork-join-executor&quot;</span>
  <span class="n">fork</span><span class="o">-</span><span class="n">join</span><span class="o">-</span><span class="n">executor</span> <span class="o">{</span>
    <span class="n">parallelism</span><span class="o">-</span><span class="n">min</span> <span class="k">=</span> <span class="mi">2</span>
    <span class="n">parallelism</span><span class="o">-</span><span class="n">max</span> <span class="k">=</span> <span class="mi">4</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://akka.io/faq">FAQ</a></li>
      <li><a href="http://typesafe.com/stack/downloads/akka">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>      
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>      
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://typesafe.com/products/typesafe-subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@typesafe.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/watermark.png" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2013 <a href="http://typesafe.com/">Typesafe Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Oct 23, 2013
    </p>          
  </div>
</div>
<script src="http://www.google.com/jsapi" type="text/javascript"></script>
<script type="text/javascript">
    google.load('search', '1', {language : 'en', style : google.loader.themes.MINIMALIST});
    google.setOnLoadCallback(function() {
    var customSearchOptions = {};  var customSearchControl = new google.search.CustomSearchControl(
    '003065520604945464838:izzukx8-qba', customSearchOptions);
    customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
    customSearchControl.draw('cse');
    var path = window.location.pathname.split('/').slice(0,4);
    if(window.location.hostname && path.length >= 4) {
    var site = "site:" + window.location.hostname + path.join('/').toString();
    customSearchControl.setSearchStartingCallback(this, function(c, s, q) { s.setQueryAddition(site); });
    }
    }, true);
</script>
<style type="text/css">
    .gsc-control-cse {
    font-family: Arial, sans-serif;
    border-color: rgb(242, 242, 235);
    background-color: rgb(242, 242, 235);
    }
    .gsc-control-cse .gsc-table-result {
      font-family: Arial, sans-serif;
      display: block;
    }
    input.gsc-input {
    border-color: #BBBBBB;
    }
    input.gsc-search-button {
    border-color: rgb(34, 57, 64);
    background-color: rgb(68, 114, 129);
    color: #FFFFFF;
    }
    .gsc-tabHeader.gsc-tabhInactive {
    border-color: #777777;
    background-color: #777777;
    }
    .gsc-tabHeader.gsc-tabhActive {
    border-color: #333333;
    background-color: #333333;
    }
    .gsc-tabsArea {
    border-color: #333333;
    }
    .gsc-webResult.gsc-result,
    .gsc-results .gsc-imageResult {
      border-color: #666666;
      background-color: #FFFFFF;
      padding: 0.5em 0.5em;
    }
    .gsc-webResult.gsc-result:hover,
    .gsc-imageResult:hover {
      border-color: #AAAAAA;
      background-color: #FFFFFF;
      padding: 0.5em 0.5em;
    }
    .gsc-webResult.gsc-result.gsc-promotion:hover {
    border-color: #AAAAAA;
    background-color: #FFFFFF;
    }
    .gs-webResult.gs-result a.gs-title:link,
    .gs-webResult.gs-result a.gs-title:link b,
    .gs-imageResult a.gs-title:link,
    .gs-imageResult a.gs-title:link b {
    color: #444444;
    }
    .gs-webResult.gs-result a.gs-title:visited,
    .gs-webResult.gs-result a.gs-title:visited b,
    .gs-imageResult a.gs-title:visited,
    .gs-imageResult a.gs-title:visited b {
    color: #444444;
    }
    .gs-webResult.gs-result a.gs-title:hover,
    .gs-webResult.gs-result a.gs-title:hover b,
    .gs-imageResult a.gs-title:hover,
    .gs-imageResult a.gs-title:hover b {
    color: #444444;
    }
    .gs-webResult.gs-result a.gs-title:active,
    .gs-webResult.gs-result a.gs-title:active b,
    .gs-imageResult a.gs-title:active,
    .gs-imageResult a.gs-title:active b {
    color: #777777;
    }
    .gsc-cursor-page {
    color: #444444;
    }
    a.gsc-trailing-more-results:link {
    color: #444444;
    }
    .gs-webResult .gs-snippet,
    .gs-imageResult .gs-snippet,
    .gs-fileFormatType {
    color: #333333;
    }
    .gs-webResult div.gs-visibleUrl,
    .gs-imageResult div.gs-visibleUrl {
    color: #000000;
    }
    .gs-webResult div.gs-visibleUrl-short {
    color: #000000;
    }
    .gs-webResult div.gs-visibleUrl-short {
    display: none;
    }
    .gs-webResult div.gs-visibleUrl-long {
    display: block;
    }
    .gs-promotion div.gs-visibleUrl-short {
    display: none;
    }
    .gs-promotion div.gs-visibleUrl-long {
    display: block;
    }
    .gsc-cursor-box {
    border-color: #FFFFFF;
    }
    .gsc-results .gsc-cursor-box .gsc-cursor-page {
    border-color: #777777;
    background-color: #FFFFFF;
    color: #444444;
    }
    .gsc-results .gsc-cursor-box .gsc-cursor-current-page {
    border-color: #333333;
    background-color: #333333;
    color: #444444;
    }
    .gsc-webResult.gsc-result.gsc-promotion {
    border-color: #CCCCCC;
    background-color: #E6E6E6;
    }
    .gsc-completion-title {
    color: #444444;
    }
    .gsc-completion-snippet {
    color: #333333;
    }
    .gs-promotion a.gs-title:link,
    .gs-promotion a.gs-title:link *,
    .gs-promotion .gs-snippet a:link {
    color: #0000CC;
    }
    .gs-promotion a.gs-title:visited,
    .gs-promotion a.gs-title:visited *,
    .gs-promotion .gs-snippet a:visited {
    color: #0000CC;
    }
    .gs-promotion a.gs-title:hover,
    .gs-promotion a.gs-title:hover *,
    .gs-promotion .gs-snippet a:hover {
    color: #444444;
    }
    .gs-promotion a.gs-title:active,
    .gs-promotion a.gs-title:active *,
    .gs-promotion .gs-snippet a:active {
    color: #00CC00;
    }
    .gs-promotion .gs-snippet,
    .gs-promotion .gs-title .gs-promotion-title-right,
    .gs-promotion .gs-title .gs-promotion-title-right *  {
    color: #333333;
    }
    .gs-promotion .gs-visibleUrl,
    .gs-promotion .gs-visibleUrl-short {
    color: #00CC00;
    }
</style>
<script type="text/javascript">
  $('#toc').toc();
</script>
  

  </body>
</html>