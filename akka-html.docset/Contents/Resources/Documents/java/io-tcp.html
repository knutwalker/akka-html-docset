


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Using TCP &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Exo:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Networking" href="index-network.html" />
    <link rel="next" title="Using UDP" href="io-udp.html" />
    <link rel="prev" title="Encoding and decoding binary data" href="io-codec.html" />
    <!--Google Analytics-->
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-21117439-1']);
      _gaq.push(['_setDomainName', 'akka.io']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })()
    </script>

  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img src="../_static/logo-small.png" /></a>
        </div>    
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://akka.io/faq">FAQ</a></li>
          <li><a href="http://typesafe.com/stack/downloads/akka">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>           
          <li><a href="http://typesafe.com/products/typesafe-subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Using TCP</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">           
              <li>
                 <span class="divider">|</span> <a href="io-udp.html">Using UDP</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../index.html">Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="io-codec.html">Encoding and decoding binary data</a> <span class="divider">|</span>
              </li>
              <li>
                Version 2.2.3
              </li>
            </ul>
          </div>
        </div>
        <div class="row">
          <div class="span9">
            <div id="cse">Loading</div>
          </div><div class="span9">
            
  <div class="section" id="using-tcp">
<span id="io-java-tcp"></span><h1>Using TCP</h1>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The IO implementation is marked as <strong>“experimental”</strong> as of its introduction
in Akka 2.2.0. We will continue to improve this API based on our users’
feedback, which implies that while we try to keep incompatible changes to a
minimum the binary compatibility guarantee for maintenance releases does not
apply to the contents of the <cite>akka.io</cite> package.</p>
</div>
<p>The code snippets through-out this section assume the following imports:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorRef</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.actor.Props</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.actor.UntypedActor</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.io.Tcp</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.io.Tcp.Bound</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.io.Tcp.CommandFailed</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.io.Tcp.Connected</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.io.Tcp.ConnectionClosed</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.io.Tcp.Received</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.io.TcpMessage</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.japi.Procedure</span><span class="o">;</span>
<span class="k">import</span> <span class="nn">akka.util.ByteString</span><span class="o">;</span>
</pre></div>
</div>
<p>All of the Akka I/O APIs are accessed through manager objects. When using an I/O API, the first step is to acquire a
reference to the appropriate manager. The code below shows how to acquire a reference to the <tt class="docutils literal"><span class="pre">Tcp</span></tt> manager.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">tcpManager</span> <span class="k">=</span> <span class="nc">Tcp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">getContext</span><span class="o">().</span><span class="n">system</span><span class="o">()).</span><span class="n">manager</span><span class="o">();</span>
</pre></div>
</div>
<p>The manager is an actor that handles the underlying low level I/O resources (selectors, channels) and instantiates
workers for specific tasks, such as listening to incoming connections.</p>
<div class="section" id="connecting">
<h2>Connecting</h2>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">Client</span> <span class="k">extends</span> <span class="nc">UntypedActor</span> <span class="o">{</span>
  
  <span class="k">final</span> <span class="nc">InetSocketAddress</span> <span class="n">remote</span><span class="o">;</span>
  <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">listener</span><span class="o">;</span>

  <span class="n">public</span> <span class="nc">Client</span><span class="o">(</span><span class="nc">InetSocketAddress</span> <span class="n">remote</span><span class="o">,</span> <span class="nc">ActorRef</span> <span class="n">listener</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">remote</span> <span class="k">=</span> <span class="n">remote</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="n">listener</span> <span class="k">=</span> <span class="n">listener</span><span class="o">;</span>
    
    <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">tcp</span> <span class="k">=</span> <span class="nc">Tcp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">getContext</span><span class="o">().</span><span class="n">system</span><span class="o">()).</span><span class="n">manager</span><span class="o">();</span>
    <span class="n">tcp</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="n">remote</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">onReceive</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">CommandFailed</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">listener</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="s">&quot;failed&quot;</span><span class="o">,</span> <span class="n">getSelf</span><span class="o">());</span>
      <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>
      
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Connected</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">listener</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">getSelf</span><span class="o">());</span>
      <span class="n">getSender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">register</span><span class="o">(</span><span class="n">getSelf</span><span class="o">()),</span> <span class="n">getSelf</span><span class="o">());</span>
      <span class="n">getContext</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">connected</span><span class="o">(</span><span class="n">getSender</span><span class="o">()));</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">connected</span><span class="o">(</span><span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">connection</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="n">public</span> <span class="n">void</span> <span class="n">apply</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        
        <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">ByteString</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">connection</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">write</span><span class="o">((</span><span class="nc">ByteString</span><span class="o">)</span> <span class="n">msg</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
      
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">CommandFailed</span><span class="o">)</span> <span class="o">{</span>
          <span class="c1">// OS kernel socket buffer was full</span>
        
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Received</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">listener</span><span class="o">.</span><span class="n">tell</span><span class="o">(((</span><span class="nc">Received</span><span class="o">)</span> <span class="n">msg</span><span class="o">).</span><span class="n">data</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">());</span>
        
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="s">&quot;close&quot;</span><span class="o">))</span> <span class="o">{</span>
          <span class="n">connection</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">close</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">());</span>
        
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">ConnectionClosed</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">};</span>
  <span class="o">}</span>
  
<span class="o">}</span>
</pre></div>
</div>
<p>The first step of connecting to a remote address is sending a <tt class="xref py py-class docutils literal"><span class="pre">Connect</span></tt>
message to the TCP manager; in addition to the simplest form shown above there
is also the possibility to specify a local <tt class="xref py py-class docutils literal"><span class="pre">InetSocketAddress</span></tt> to bind
to and a list of socket options to apply.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The SO_NODELAY (TCP_NODELAY on Windows) socket option defaults to true in
Akka, independently of the OS default settings. This setting disables Nagle's
algorithm, considerably improving latency for most applications. This setting
could be overridden by passing <tt class="docutils literal"><span class="pre">SO.TcpNoDelay(false)</span></tt> in the list of socket
options of the <tt class="docutils literal"><span class="pre">Connect</span></tt> message.</p>
</div>
<p>The TCP manager will then reply either with a <tt class="xref py py-class docutils literal"><span class="pre">CommandFailed</span></tt> or it will
spawn an internal actor representing the new connection. This new actor will
then send a <tt class="xref py py-class docutils literal"><span class="pre">Connected</span></tt> message to the original sender of the
<tt class="xref py py-class docutils literal"><span class="pre">Connect</span></tt> message.</p>
<p>In order to activate the new connection a <tt class="xref py py-class docutils literal"><span class="pre">Register</span></tt> message must be
sent to the connection actor, informing that one about who shall receive data
from the socket. Before this step is done the connection cannot be used, and
there is an internal timeout after which the connection actor will shut itself
down if no <tt class="xref py py-class docutils literal"><span class="pre">Register</span></tt> message is received.</p>
<p>The connection actor watches the registered handler and closes the connection
when that one terminates, thereby cleaning up all internal resources associated
with that connection.</p>
<p>The actor in the example above uses <tt class="xref py py-meth docutils literal"><span class="pre">become</span></tt> to switch from unconnected
to connected operation, demonstrating the commands and events which are
observed in that state. For a discussion on <tt class="xref py py-class docutils literal"><span class="pre">CommandFailed</span></tt> see
<a class="reference internal" href="io-tcp.html#throttling-reads-and-writes">Throttling Reads and Writes</a> below. <tt class="xref py py-class docutils literal"><span class="pre">ConnectionClosed</span></tt> is a trait,
which marks the different connection close events. The last line handles all
connection close events in the same way. It is possible to listen for more
fine-grained connection close events, see <a class="reference internal" href="io-tcp.html#closing-connections">Closing Connections</a> below.</p>
</div>
<div class="section" id="accepting-connections">
<h2>Accepting connections</h2>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">Server</span> <span class="k">extends</span> <span class="nc">UntypedActor</span> <span class="o">{</span>
  
  <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">manager</span><span class="o">;</span>
  
  <span class="n">public</span> <span class="nc">Server</span><span class="o">(</span><span class="nc">ActorRef</span> <span class="n">manager</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">manager</span> <span class="k">=</span> <span class="n">manager</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">preStart</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">tcp</span> <span class="k">=</span> <span class="nc">Tcp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">getContext</span><span class="o">().</span><span class="n">system</span><span class="o">()).</span><span class="n">manager</span><span class="o">();</span>
    <span class="n">tcp</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">bind</span><span class="o">(</span><span class="n">getSelf</span><span class="o">(),</span>
        <span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="mi">100</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">onReceive</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Bound</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">manager</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">getSelf</span><span class="o">());</span>

    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">CommandFailed</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>
    
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Connected</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">final</span> <span class="nc">Connected</span> <span class="n">conn</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Connected</span><span class="o">)</span> <span class="n">msg</span><span class="o">;</span>
      <span class="n">manager</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="n">conn</span><span class="o">,</span> <span class="n">getSelf</span><span class="o">());</span>
      <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">handler</span> <span class="k">=</span> <span class="n">getContext</span><span class="o">().</span><span class="n">actorOf</span><span class="o">(</span>
          <span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">SimplisticHandler</span><span class="o">.</span><span class="n">class</span><span class="o">));</span>
      <span class="n">getSender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">register</span><span class="o">(</span><span class="n">handler</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
<span class="o">}</span>
</pre></div>
</div>
<p>To create a TCP server and listen for inbound connections, a <tt class="xref py py-class docutils literal"><span class="pre">Bind</span></tt>
command has to be sent to the TCP manager.  This will instruct the TCP manager
to listen for TCP connections on a particular <tt class="xref py py-class docutils literal"><span class="pre">InetSocketAddress</span></tt>; the
port may be specified as <tt class="docutils literal"><span class="pre">0</span></tt> in order to bind to a random port.</p>
<p>The actor sending the <tt class="xref py py-class docutils literal"><span class="pre">Bind</span></tt> message will receive a <tt class="xref py py-class docutils literal"><span class="pre">Bound</span></tt>
message signalling that the server is ready to accept incoming connections;
this message also contains the <tt class="xref py py-class docutils literal"><span class="pre">InetSocketAddress</span></tt> to which the socket
was actually bound (i.e. resolved IP address and correct port number).</p>
<p>From this point forward the process of handling connections is the same as for
outgoing connections. The example demonstrates that handling the reads from a
certain connection can be delegated to another actor by naming it as the
handler when sending the <tt class="xref py py-class docutils literal"><span class="pre">Register</span></tt> message. Writes can be sent from any
actor in the system to the connection actor (i.e. the actor which sent the
<tt class="xref py py-class docutils literal"><span class="pre">Connected</span></tt> message). The simplistic handler is defined as:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">SimplisticHandler</span> <span class="k">extends</span> <span class="nc">UntypedActor</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">onReceive</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Received</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">final</span> <span class="nc">ByteString</span> <span class="n">data</span> <span class="k">=</span> <span class="o">((</span><span class="nc">Received</span><span class="o">)</span> <span class="n">msg</span><span class="o">).</span><span class="n">data</span><span class="o">();</span>
      <span class="nc">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
      <span class="n">getSender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">write</span><span class="o">(</span><span class="n">data</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">ConnectionClosed</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>For a more complete sample which also takes into account the possibility of
failures when sending please see <a class="reference internal" href="io-tcp.html#throttling-reads-and-writes">Throttling Reads and Writes</a> below.</p>
<p>The only difference to outgoing connections is that the internal actor managing
the listen port—the sender of the <tt class="xref py py-class docutils literal"><span class="pre">Bound</span></tt> message—watches the actor
which was named as the recipient for <tt class="xref py py-class docutils literal"><span class="pre">Connected</span></tt> messages in the
<tt class="xref py py-class docutils literal"><span class="pre">Bind</span></tt> message. When that actor terminates the listen port will be
closed and all resources associated with it will be released; existing
connections will not be terminated at this point.</p>
</div>
<div class="section" id="closing-connections">
<h2>Closing connections</h2>
<p>A connection can be closed by sending one of the commands <tt class="docutils literal"><span class="pre">Close</span></tt>, <tt class="docutils literal"><span class="pre">ConfirmedClose</span></tt> or <tt class="docutils literal"><span class="pre">Abort</span></tt> to the connection
actor.</p>
<p><tt class="docutils literal"><span class="pre">Close</span></tt> will close the connection by sending a <tt class="docutils literal"><span class="pre">FIN</span></tt> message, but without waiting for confirmation from
the remote endpoint. Pending writes will be flushed. If the close is successful, the listener will be notified with
<tt class="docutils literal"><span class="pre">Closed</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">ConfirmedClose</span></tt> will close the sending direction of the connection by sending a <tt class="docutils literal"><span class="pre">FIN</span></tt> message, but data
will continue to be received until the remote endpoint closes the connection, too. Pending writes will be flushed. If the close is
successful, the listener will be notified with <tt class="docutils literal"><span class="pre">ConfirmedClosed</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Abort</span></tt> will immediately terminate the connection by sending a <tt class="docutils literal"><span class="pre">RST</span></tt> message to the remote endpoint. Pending
writes will be not flushed. If the close is successful, the listener will be notified with <tt class="docutils literal"><span class="pre">Aborted</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">PeerClosed</span></tt> will be sent to the listener if the connection has been closed by the remote endpoint. Per default, the
connection will then automatically be closed from this endpoint as well. To support half-closed connections set the
<tt class="docutils literal"><span class="pre">keepOpenOnPeerClosed</span></tt> member of the <tt class="docutils literal"><span class="pre">Register</span></tt> message to <tt class="docutils literal"><span class="pre">true</span></tt> in which case the connection stays open until
it receives one of the above close commands.</p>
<p><tt class="docutils literal"><span class="pre">ErrorClosed</span></tt> will be sent to the listener whenever an error happened that forced the connection to be closed.</p>
<p>All close notifications are sub-types of <tt class="docutils literal"><span class="pre">ConnectionClosed</span></tt> so listeners who do not need fine-grained close events
may handle all close events in the same way.</p>
</div>
<div class="section" id="writing-to-a-connection">
<h2>Writing to a connection</h2>
<p>Once a connection has been established data can be sent to it from any actor in the form of a <tt class="docutils literal"><span class="pre">Tcp.WriteCommand</span></tt>.
<tt class="docutils literal"><span class="pre">Tcp.WriteCommand</span></tt> is an abstract class with three concrete implementations:</p>
<dl class="docutils">
<dt>Tcp.Write</dt>
<dd>The simplest <tt class="docutils literal"><span class="pre">WriteCommand</span></tt> implementation which wraps a <tt class="docutils literal"><span class="pre">ByteString</span></tt> instance and an &quot;ack&quot; event.
A <tt class="docutils literal"><span class="pre">ByteString</span></tt> (as explained in <a class="reference internal" href="../scala/io.html#bytestring"><em>this section</em></a>) models one or more chunks of immutable
in-memory data with a maximum (total) size of 2 GB (2^31 bytes).</dd>
<dt>Tcp.WriteFile</dt>
<dd>If you want to send &quot;raw&quot; data from a file you can do so efficiently with the <tt class="docutils literal"><span class="pre">Tcp.WriteFile</span></tt> command.
This allows you do designate a (contiguous) chunk of on-disk bytes for sending across the connection without
the need to first load them into the JVM memory. As such <tt class="docutils literal"><span class="pre">Tcp.WriteFile</span></tt> can &quot;hold&quot; more than 2GB of data and
an &quot;ack&quot; event if required.</dd>
<dt>Tcp.CompoundWrite</dt>
<dd><p class="first">Sometimes you might want to group (or interleave) several <tt class="docutils literal"><span class="pre">Tcp.Write</span></tt> and/or <tt class="docutils literal"><span class="pre">Tcp.WriteFile</span></tt> commands into
one atomic write command which gets written to the connection in one go. The <tt class="docutils literal"><span class="pre">Tcp.CompoundWrite</span></tt> allows you
to do just that and offers three benefits:</p>
<ol class="last arabic simple">
<li>As explained in the following section the TCP connection actor can only handle one single write command at a time.
By combining several writes into one <tt class="docutils literal"><span class="pre">CompoundWrite</span></tt> you can have them be sent across the connection with
minimum overhead and without the need to spoon feed them to the connection actor via an <em>ACK-based</em> message
protocol.</li>
<li>Because a <tt class="docutils literal"><span class="pre">WriteCommand</span></tt> is atomic you can be sure that no other actor can &quot;inject&quot; other writes into your
series of writes if you combine them into one single <tt class="docutils literal"><span class="pre">CompoundWrite</span></tt>. In scenarios where several actors write
to the same connection this can be an important feature which can be somewhat hard to achieve otherwise.</li>
<li>The &quot;sub writes&quot; of a <tt class="docutils literal"><span class="pre">CompoundWrite</span></tt> are regular <tt class="docutils literal"><span class="pre">Write</span></tt> or <tt class="docutils literal"><span class="pre">WriteFile</span></tt> commands that themselves can request
&quot;ack&quot; events. These ACKs are sent out as soon as the respective &quot;sub write&quot; has been completed. This allows you to
attach more than one ACK to a <tt class="docutils literal"><span class="pre">Write</span></tt> or <tt class="docutils literal"><span class="pre">WriteFile</span></tt> (by combining it with an empty write that itself requests
an ACK) or to have the connection actor acknowledge the progress of transmitting the <tt class="docutils literal"><span class="pre">CompoundWrite</span></tt> by sending
out intermediate ACKs at arbitrary points.</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="throttling-reads-and-writes">
<h2>Throttling Reads and Writes</h2>
<p>The basic model of the TCP connection actor is that it has no internal
buffering (i.e. it can only process one write at a time, meaning it can buffer
one write until it has been passed on to the O/S kernel in full). Congestion
needs to be handled at the user level, for which there are three modes of
operation:</p>
<ul class="simple">
<li><em>ACK-based:</em> every <tt class="xref py py-class docutils literal"><span class="pre">Write</span></tt> command carries an arbitrary object, and if
this object is not <tt class="docutils literal"><span class="pre">Tcp.NoAck</span></tt> then it will be returned to the sender of
the <tt class="xref py py-class docutils literal"><span class="pre">Write</span></tt> upon successfully writing all contained data to the
socket. If no other write is initiated before having received this
acknowledgement then no failures can happen due to buffer overrun.</li>
<li><em>NACK-based:</em> every write which arrives while a previous write is not yet
completed will be replied to with a <tt class="xref py py-class docutils literal"><span class="pre">CommandFailed</span></tt> message containing
the failed write. Just relying on this mechanism requires the implemented
protocol to tolerate skipping writes (e.g. if each write is a valid message
on its own and it is not required that all are delivered). This mode is
enabled by setting the <tt class="docutils literal"><span class="pre">useResumeWriting</span></tt> flag to <tt class="docutils literal"><span class="pre">false</span></tt> within the
<tt class="xref py py-class docutils literal"><span class="pre">Register</span></tt> message during connection activation.</li>
<li><em>NACK-based with write suspending:</em> this mode is very similar to the
NACK-based one, but once a single write has failed no further writes will
succeed until a <tt class="xref py py-class docutils literal"><span class="pre">ResumeWriting</span></tt> message is received. This message will
be answered with a <tt class="xref py py-class docutils literal"><span class="pre">WritingResumed</span></tt> message once the last accepted
write has completed. If the actor driving the connection implements buffering
and resends the NACK’ed messages after having awaited the
<tt class="xref py py-class docutils literal"><span class="pre">WritingResumed</span></tt> signal then every message is delivered exactly once
to the network socket.</li>
</ul>
<p>These models (with the exception of the second which is rather specialised) are
demonstrated in complete examples below. The full and contiguous source is
available <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-docs/rst/java/code/docs/io/japi">on github</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It should be obvious that all these flow control schemes only work between
one writer and one connection actor; as soon as multiple actors send write
commands to a single connection no consistent result can be achieved.</p>
</div>
</div>
<div class="section" id="ack-based-back-pressure">
<h2>ACK-Based Back-Pressure</h2>
<p>For proper function of the following example it is important to configure the
connection to remain half-open when the remote side closed its writing end:
this allows the example <tt class="xref py py-class docutils literal"><span class="pre">EchoHandler</span></tt> to write all outstanding data back
to the client before fully closing the connection. This is enabled using a flag
upon connection activation (observe the <tt class="xref py py-class docutils literal"><span class="pre">Register</span></tt> message):</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">connection</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">register</span><span class="o">(</span><span class="n">handler</span><span class="o">,</span>
    <span class="kc">true</span><span class="o">,</span> <span class="c1">// &lt;-- keepOpenOnPeerClosed flag</span>
    <span class="kc">true</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
</pre></div>
</div>
<p>With this preparation let us dive into the handler itself:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">SimpleEchoHandler</span> <span class="k">extends</span> <span class="nc">UntypedActor</span> <span class="o">{</span>
  
  <span class="k">final</span> <span class="nc">LoggingAdapter</span> <span class="n">log</span> <span class="k">=</span> <span class="nc">Logging</span>
      <span class="o">.</span><span class="n">getLogger</span><span class="o">(</span><span class="n">getContext</span><span class="o">().</span><span class="n">system</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">());</span>

  <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">connection</span><span class="o">;</span>
  <span class="k">final</span> <span class="nc">InetSocketAddress</span> <span class="n">remote</span><span class="o">;</span>

  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="n">long</span> <span class="n">maxStored</span> <span class="k">=</span> <span class="mi">100000000</span><span class="o">;</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="n">long</span> <span class="n">highWatermark</span> <span class="k">=</span> <span class="n">maxStored</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="n">long</span> <span class="n">lowWatermark</span> <span class="k">=</span> <span class="n">maxStored</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>

  <span class="n">public</span> <span class="nc">SimpleEchoHandler</span><span class="o">(</span><span class="nc">ActorRef</span> <span class="n">connection</span><span class="o">,</span> <span class="nc">InetSocketAddress</span> <span class="n">remote</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">connection</span> <span class="k">=</span> <span class="n">connection</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="n">remote</span> <span class="k">=</span> <span class="n">remote</span><span class="o">;</span>

    <span class="c1">// sign death pact: this actor stops when the connection is closed</span>
    <span class="n">getContext</span><span class="o">().</span><span class="n">watch</span><span class="o">(</span><span class="n">connection</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">onReceive</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Received</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">final</span> <span class="nc">ByteString</span> <span class="n">data</span> <span class="k">=</span> <span class="o">((</span><span class="nc">Received</span><span class="o">)</span> <span class="n">msg</span><span class="o">).</span><span class="n">data</span><span class="o">();</span>
      <span class="n">buffer</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
      <span class="n">connection</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">write</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="nc">ACK</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
      <span class="c1">// now switch behavior to “waiting for acknowledgement”</span>
      <span class="n">getContext</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">buffering</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>

    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">ConnectionClosed</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">buffering</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">apply</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Received</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">buffer</span><span class="o">(((</span><span class="nc">Received</span><span class="o">)</span> <span class="n">msg</span><span class="o">).</span><span class="n">data</span><span class="o">());</span>
        
      <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">==</span> <span class="nc">ACK</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">acknowledge</span><span class="o">();</span>

      <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">ConnectionClosed</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(((</span><span class="nc">ConnectionClosed</span><span class="o">)</span> <span class="n">msg</span><span class="o">).</span><span class="n">isPeerClosed</span><span class="o">())</span> <span class="o">{</span>
          <span class="n">closing</span> <span class="k">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="c1">// could also be ErrorClosed, in which case we just give up</span>
          <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">};</span>

  <span class="c1">// storage omitted ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The principle is simple: when having written a chunk always wait for the
<tt class="docutils literal"><span class="pre">Ack</span></tt> to come back before sending the next chunk. While waiting we switch
behavior such that new incoming data are buffered. The helper functions used
are a bit lengthy but not complicated:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">protected</span> <span class="n">void</span> <span class="n">buffer</span><span class="o">(</span><span class="nc">ByteString</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">storage</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
  <span class="n">stored</span> <span class="o">+=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="o">();</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">stored</span> <span class="o">&gt;</span> <span class="n">maxStored</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="o">(</span><span class="s">&quot;drop connection to [{}] (buffer overrun)&quot;</span><span class="o">,</span> <span class="n">remote</span><span class="o">);</span>
    <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>

  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">stored</span> <span class="o">&gt;</span> <span class="n">highWatermark</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="o">(</span><span class="s">&quot;suspending reading&quot;</span><span class="o">);</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">suspendReading</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">());</span>
    <span class="n">suspended</span> <span class="k">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">protected</span> <span class="n">void</span> <span class="n">acknowledge</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">final</span> <span class="nc">ByteString</span> <span class="n">acked</span> <span class="k">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">remove</span><span class="o">();</span>
  <span class="n">stored</span> <span class="o">-=</span> <span class="n">acked</span><span class="o">.</span><span class="n">size</span><span class="o">();</span>
  <span class="n">transferred</span> <span class="o">+=</span> <span class="n">acked</span><span class="o">.</span><span class="n">size</span><span class="o">();</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">suspended</span> <span class="o">&amp;&amp;</span> <span class="n">stored</span> <span class="o">&lt;</span> <span class="n">lowWatermark</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="o">(</span><span class="s">&quot;resuming reading&quot;</span><span class="o">);</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">resumeReading</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">());</span>
    <span class="n">suspended</span> <span class="k">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="k">if</span> <span class="o">(</span><span class="n">storage</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">closing</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">getContext</span><span class="o">().</span><span class="n">unbecome</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">write</span><span class="o">(</span><span class="n">storage</span><span class="o">.</span><span class="n">peek</span><span class="o">(),</span> <span class="nc">ACK</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The most interesting part is probably the last: an <tt class="docutils literal"><span class="pre">Ack</span></tt> removes the oldest
data chunk from the buffer, and if that was the last chunk then we either close
the connection (if the peer closed its half already) or return to the idle
behavior; otherwise we just send the next buffered chunk and stay waiting for
the next <tt class="docutils literal"><span class="pre">Ack</span></tt>.</p>
<p>Back-pressure can be propagated also across the reading side back to the writer
on the other end of the connection by sending the <tt class="xref py py-class docutils literal"><span class="pre">SuspendReading</span></tt>
command to the connection actor. This will lead to no data being read from the
socket anymore (although this does happen after a delay because it takes some
time until the connection actor processes this command, hence appropriate
head-room in the buffer should be present), which in turn will lead to the O/S
kernel buffer filling up on our end, then the TCP window mechanism will stop
the remote side from writing, filling up its write buffer, until finally the
writer on the other side cannot push any data into the socket anymore. This is
how end-to-end back-pressure is realized across a TCP connection.</p>
</div>
<div class="section" id="nack-based-back-pressure-with-write-suspending">
<h2>NACK-Based Back-Pressure with Write Suspending</h2>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">EchoHandler</span> <span class="k">extends</span> <span class="nc">UntypedActor</span> <span class="o">{</span>

  <span class="k">final</span> <span class="nc">LoggingAdapter</span> <span class="n">log</span> <span class="k">=</span> <span class="nc">Logging</span>
      <span class="o">.</span><span class="n">getLogger</span><span class="o">(</span><span class="n">getContext</span><span class="o">().</span><span class="n">system</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">());</span>

  <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">connection</span><span class="o">;</span>
  <span class="k">final</span> <span class="nc">InetSocketAddress</span> <span class="n">remote</span><span class="o">;</span>

  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="n">long</span> <span class="nc">MAX_STORED</span> <span class="k">=</span> <span class="mi">100000000</span><span class="o">;</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="n">long</span> <span class="nc">HIGH_WATERMARK</span> <span class="k">=</span> <span class="nc">MAX_STORED</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="n">long</span> <span class="nc">LOW_WATERMARK</span> <span class="k">=</span> <span class="nc">MAX_STORED</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
  
  <span class="k">private</span> <span class="n">static</span> <span class="k">class</span> <span class="nc">Ack</span> <span class="n">implements</span> <span class="nc">Event</span> <span class="o">{</span>
    <span class="n">public</span> <span class="k">final</span> <span class="n">int</span> <span class="n">ack</span><span class="o">;</span>
    <span class="n">public</span> <span class="nc">Ack</span><span class="o">(</span><span class="n">int</span> <span class="n">ack</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="n">ack</span> <span class="k">=</span> <span class="n">ack</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="n">public</span> <span class="nc">EchoHandler</span><span class="o">(</span><span class="nc">ActorRef</span> <span class="n">connection</span><span class="o">,</span> <span class="nc">InetSocketAddress</span> <span class="n">remote</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">connection</span> <span class="k">=</span> <span class="n">connection</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="n">remote</span> <span class="k">=</span> <span class="n">remote</span><span class="o">;</span>

    <span class="c1">// sign death pact: this actor stops when the connection is closed</span>
    <span class="n">getContext</span><span class="o">().</span><span class="n">watch</span><span class="o">(</span><span class="n">connection</span><span class="o">);</span>

    <span class="c1">// start out in optimistic write-through mode</span>
    <span class="n">getContext</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">writing</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">writing</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">apply</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Received</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">final</span> <span class="nc">ByteString</span> <span class="n">data</span> <span class="k">=</span> <span class="o">((</span><span class="nc">Received</span><span class="o">)</span> <span class="n">msg</span><span class="o">).</span><span class="n">data</span><span class="o">();</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">write</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Ack</span><span class="o">(</span><span class="n">currentOffset</span><span class="o">())),</span> <span class="n">getSelf</span><span class="o">());</span>
        <span class="n">buffer</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>

      <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Integer</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">acknowledge</span><span class="o">((</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">msg</span><span class="o">);</span>

      <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">CommandFailed</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">final</span> <span class="nc">Write</span> <span class="n">w</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Write</span><span class="o">)</span> <span class="o">((</span><span class="nc">CommandFailed</span><span class="o">)</span> <span class="n">msg</span><span class="o">).</span><span class="n">cmd</span><span class="o">();</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">resumeWriting</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">());</span>
        <span class="n">getContext</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">buffering</span><span class="o">((</span><span class="nc">Ack</span><span class="o">)</span> <span class="n">w</span><span class="o">.</span><span class="n">ack</span><span class="o">()));</span>

      <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">ConnectionClosed</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">final</span> <span class="nc">ConnectionClosed</span> <span class="n">cl</span> <span class="k">=</span> <span class="o">(</span><span class="nc">ConnectionClosed</span><span class="o">)</span> <span class="n">msg</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cl</span><span class="o">.</span><span class="n">isPeerClosed</span><span class="o">())</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">storage</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>
          <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">getContext</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">closing</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">};</span>

  <span class="c1">// buffering ...</span>

  <span class="c1">// closing ...</span>

  <span class="c1">// storage omitted ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The principle here is to keep writing until a <tt class="xref py py-class docutils literal"><span class="pre">CommandFailed</span></tt> is
received, using acknowledgements only to prune the resend buffer. When a such a
failure was received, transition into a different state for handling and handle
resending of all queued data:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">protected</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">buffering</span><span class="o">(</span><span class="k">final</span> <span class="nc">Ack</span> <span class="n">nack</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;()</span> <span class="o">{</span>

    <span class="k">private</span> <span class="n">int</span> <span class="n">toAck</span> <span class="k">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="k">private</span> <span class="n">boolean</span> <span class="n">peerClosed</span> <span class="k">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">apply</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Received</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">buffer</span><span class="o">(((</span><span class="nc">Received</span><span class="o">)</span> <span class="n">msg</span><span class="o">).</span><span class="n">data</span><span class="o">());</span>

      <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">WritingResumed</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">writeFirst</span><span class="o">();</span>

      <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">ConnectionClosed</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(((</span><span class="nc">ConnectionClosed</span><span class="o">)</span> <span class="n">msg</span><span class="o">).</span><span class="n">isPeerClosed</span><span class="o">())</span>
          <span class="n">peerClosed</span> <span class="k">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">else</span>
          <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>

      <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Integer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">final</span> <span class="n">int</span> <span class="n">ack</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">msg</span><span class="o">;</span>
        <span class="n">acknowledge</span><span class="o">(</span><span class="n">ack</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">ack</span> <span class="o">&gt;=</span> <span class="n">nack</span><span class="o">.</span><span class="n">ack</span><span class="o">)</span> <span class="o">{</span>
          <span class="c1">// otherwise it was the ack of the last successful write</span>

          <span class="k">if</span> <span class="o">(</span><span class="n">storage</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">peerClosed</span><span class="o">)</span>
              <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>
            <span class="k">else</span>
              <span class="n">getContext</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">writing</span><span class="o">);</span>

          <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">toAck</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
              <span class="c1">// stay in ACK-based mode for a short while</span>
              <span class="n">writeFirst</span><span class="o">();</span>
              <span class="o">--</span><span class="n">toAck</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
              <span class="c1">// then return to NACK-based again</span>
              <span class="n">writeAll</span><span class="o">();</span>
              <span class="k">if</span> <span class="o">(</span><span class="n">peerClosed</span><span class="o">)</span>
                <span class="n">getContext</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">closing</span><span class="o">);</span>
              <span class="k">else</span>
                <span class="n">getContext</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">writing</span><span class="o">);</span>
            <span class="o">}</span>
          <span class="o">}</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">};</span>
<span class="o">}</span>
</pre></div>
</div>
<p>It should be noted that all writes which are currently buffered have also been
sent to the connection actor upon entering this state, which means that the
<tt class="xref py py-class docutils literal"><span class="pre">ResumeWriting</span></tt> message is enqueued after those writes, leading to the
reception of all outstanding <tt class="xref py py-class docutils literal"><span class="pre">CommandFailed</span></tt> messages (which are ignored
in this state) before receiving the <tt class="xref py py-class docutils literal"><span class="pre">WritingResumed</span></tt> signal. That latter
message is sent by the connection actor only once the internally queued write
has been fully completed, meaning that a subsequent write will not fail. This
is exploited by the <tt class="xref py py-class docutils literal"><span class="pre">EchoHandler</span></tt> to switch to an ACK-based approach for
the first ten writes after a failure before resuming the optimistic
write-through behavior.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">protected</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">closing</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">apply</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">CommandFailed</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// the command can only have been a Write</span>
      <span class="n">connection</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">resumeWriting</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">());</span>
      <span class="n">getContext</span><span class="o">().</span><span class="n">become</span><span class="o">(</span><span class="n">closeResend</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Integer</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">acknowledge</span><span class="o">((</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">msg</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">storage</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">())</span>
        <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">};</span>

<span class="k">protected</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">closeResend</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">apply</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">WritingResumed</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">writeAll</span><span class="o">();</span>
      <span class="n">getContext</span><span class="o">().</span><span class="n">unbecome</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Integer</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">acknowledge</span><span class="o">((</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">};</span>
</pre></div>
</div>
<p>Closing the connection while still sending all data is a bit more involved than
in the ACK-based approach: the idea is to always send all outstanding messages
and acknowledge all successful writes, and if a failure happens then switch
behavior to await the <tt class="xref py py-class docutils literal"><span class="pre">WritingResumed</span></tt> event and start over.</p>
<p>The helper functions are very similar to the ACK-based case:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">protected</span> <span class="n">void</span> <span class="n">buffer</span><span class="o">(</span><span class="nc">ByteString</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">storage</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
  <span class="n">stored</span> <span class="o">+=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="o">();</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">stored</span> <span class="o">&gt;</span> <span class="nc">MAX_STORED</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="o">(</span><span class="s">&quot;drop connection to [{}] (buffer overrun)&quot;</span><span class="o">,</span> <span class="n">remote</span><span class="o">);</span>
    <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>

  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">stored</span> <span class="o">&gt;</span> <span class="nc">HIGH_WATERMARK</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="o">(</span><span class="s">&quot;suspending reading at {}&quot;</span><span class="o">,</span> <span class="n">currentOffset</span><span class="o">());</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">suspendReading</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">());</span>
    <span class="n">suspended</span> <span class="k">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">protected</span> <span class="n">void</span> <span class="n">acknowledge</span><span class="o">(</span><span class="n">int</span> <span class="n">ack</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">assert</span> <span class="n">ack</span> <span class="o">==</span> <span class="n">storageOffset</span><span class="o">;</span>
  <span class="n">assert</span> <span class="o">!</span><span class="n">storage</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">();</span>

  <span class="k">final</span> <span class="nc">ByteString</span> <span class="n">acked</span> <span class="k">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">remove</span><span class="o">();</span>
  <span class="n">stored</span> <span class="o">-=</span> <span class="n">acked</span><span class="o">.</span><span class="n">size</span><span class="o">();</span>
  <span class="n">transferred</span> <span class="o">+=</span> <span class="n">acked</span><span class="o">.</span><span class="n">size</span><span class="o">();</span>
  <span class="n">storageOffset</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">suspended</span> <span class="o">&amp;&amp;</span> <span class="n">stored</span> <span class="o">&lt;</span> <span class="nc">LOW_WATERMARK</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="o">(</span><span class="s">&quot;resuming reading&quot;</span><span class="o">);</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">resumeReading</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">());</span>
    <span class="n">suspended</span> <span class="k">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="usage-example-tcppipelinehandler-and-ssl">
<h2>Usage Example: TcpPipelineHandler and SSL</h2>
<p>This example shows the different parts described above working together. Let us
first look at the SSL server:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">SslServer</span> <span class="k">extends</span> <span class="nc">UntypedActor</span> <span class="o">{</span>
  <span class="k">final</span> <span class="nc">SSLContext</span> <span class="n">sslContext</span><span class="o">;</span>
  <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">listener</span><span class="o">;</span>

  <span class="k">final</span> <span class="nc">LoggingAdapter</span> <span class="n">log</span> <span class="k">=</span> <span class="nc">Logging</span>
      <span class="o">.</span><span class="n">getLogger</span><span class="o">(</span><span class="n">getContext</span><span class="o">().</span><span class="n">system</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">());</span>

  <span class="n">public</span> <span class="nc">SslServer</span><span class="o">(</span><span class="nc">SSLContext</span> <span class="n">sslContext</span><span class="o">,</span> <span class="nc">ActorRef</span> <span class="n">listener</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">sslContext</span> <span class="k">=</span> <span class="n">sslContext</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="n">listener</span> <span class="k">=</span> <span class="n">listener</span><span class="o">;</span>

    <span class="c1">// bind to a socket, registering ourselves as incoming connection handler</span>
    <span class="nc">Tcp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">getContext</span><span class="o">().</span><span class="n">system</span><span class="o">()).</span><span class="n">getManager</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span>
        <span class="nc">TcpMessage</span><span class="o">.</span><span class="n">bind</span><span class="o">(</span><span class="n">getSelf</span><span class="o">(),</span> <span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="mi">100</span><span class="o">),</span>
        <span class="n">getSelf</span><span class="o">());</span>
  <span class="o">}</span>
  
  <span class="c1">// this will hold the pipeline handler’s context</span>
  <span class="nc">Init</span><span class="o">&lt;</span><span class="nc">WithinActorContext</span><span class="o">,</span> <span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">init</span> <span class="k">=</span> <span class="kc">null</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">onReceive</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">CommandFailed</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>
      
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Bound</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">listener</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">getSelf</span><span class="o">());</span>
      
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Connected</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// create a javax.net.ssl.SSLEngine for our peer in server mode</span>
      <span class="k">final</span> <span class="nc">InetSocketAddress</span> <span class="n">remote</span> <span class="k">=</span> <span class="o">((</span><span class="nc">Connected</span><span class="o">)</span> <span class="n">msg</span><span class="o">).</span><span class="n">remoteAddress</span><span class="o">();</span>
      <span class="k">final</span> <span class="nc">SSLEngine</span> <span class="n">engine</span> <span class="k">=</span> <span class="n">sslContext</span><span class="o">.</span><span class="n">createSSLEngine</span><span class="o">(</span>
          <span class="n">remote</span><span class="o">.</span><span class="n">getHostName</span><span class="o">(),</span> <span class="n">remote</span><span class="o">.</span><span class="n">getPort</span><span class="o">());</span>
      <span class="n">engine</span><span class="o">.</span><span class="n">setUseClientMode</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
      
      <span class="c1">// build pipeline and set up context for communicating with TcpPipelineHandler</span>
      <span class="n">init</span> <span class="k">=</span> <span class="nc">TcpPipelineHandler</span><span class="o">.</span><span class="n">withLogger</span><span class="o">(</span><span class="n">log</span><span class="o">,</span> <span class="n">sequence</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span>
          <span class="k">new</span> <span class="nc">StringByteStringAdapter</span><span class="o">(</span><span class="s">&quot;utf-8&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">DelimiterFraming</span><span class="o">(</span><span class="mi">1024</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">.</span><span class="n">fromString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">),</span> <span class="kc">true</span><span class="o">)),</span>
          <span class="k">new</span> <span class="nc">TcpReadWriteAdapter</span><span class="o">()),</span>
          <span class="k">new</span> <span class="nc">SslTlsSupport</span><span class="o">(</span><span class="n">engine</span><span class="o">)),</span>
          <span class="k">new</span> <span class="nc">BackpressureBuffer</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="mi">10000</span><span class="o">,</span> <span class="mi">1000000</span><span class="o">)));</span>
      
      <span class="c1">// create handler for pipeline, setting ourselves as payload recipient</span>
      <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">handler</span> <span class="k">=</span> <span class="n">getContext</span><span class="o">().</span><span class="n">actorOf</span><span class="o">(</span>
          <span class="nc">TcpPipelineHandler</span><span class="o">.</span><span class="n">props</span><span class="o">(</span><span class="n">init</span><span class="o">,</span> <span class="n">getSender</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">()));</span>
      
      <span class="c1">// register the SSL handler with the connection</span>
      <span class="n">getSender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">register</span><span class="o">(</span><span class="n">handler</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
    
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Init</span><span class="o">.</span><span class="nc">Event</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// unwrap TcpPipelineHandler’s event to get a Tcp.Event</span>
      <span class="k">final</span> <span class="nc">String</span> <span class="n">recv</span> <span class="k">=</span> <span class="n">init</span><span class="o">.</span><span class="n">event</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
      <span class="c1">// inform someone of the received message</span>
      <span class="n">listener</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="n">recv</span><span class="o">,</span> <span class="n">getSelf</span><span class="o">());</span>
      <span class="c1">// and reply (sender is the SSL handler created above)</span>
      <span class="n">getSender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="n">init</span><span class="o">.</span><span class="n">command</span><span class="o">(</span><span class="s">&quot;world\n&quot;</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Please refer to <a class="reference external" href="http://github.com/akka/akka/tree/v2.2.3/akka-docs/rst/java/code/docs/io/japi/SslDocTest.java">the source code</a> to see all imports.</p>
<p>The actor above binds to a local port and registers itself as the handler for
new connections.  When a new connection comes in it will create a
<tt class="xref py py-class docutils literal"><span class="pre">javax.net.ssl.SSLEngine</span></tt> (details not shown here since they vary widely
for different setups, please refer to the JDK documentation) and wrap that in
an <tt class="xref py py-class docutils literal"><span class="pre">SslTlsSupport</span></tt> pipeline stage (which is included in <tt class="docutils literal"><span class="pre">akka-actor</span></tt>).</p>
<p>This sample demonstrates a few more things: below the SSL pipeline stage we
have inserted a backpressure buffer which will generate a
<tt class="xref py py-class docutils literal"><span class="pre">HighWatermarkReached</span></tt> event to tell the upper stages to suspend writing
(generated at 10000 buffered bytes) and a <tt class="xref py py-class docutils literal"><span class="pre">LowWatermarkReached</span></tt> when
they can resume writing (when buffer empties below 1000 bytes); the buffer has
a maximum capacity of 1MB. The implementation is very similar to the NACK-based
backpressure approach presented above, please refer to the API documentation
for details about its usage. Above the SSL stage comes an adapter which
extracts only the payload data from the TCP commands and events, i.e. it speaks
<tt class="xref py py-class docutils literal"><span class="pre">ByteString</span></tt> above. The resulting byte streams are broken into frames by
a <tt class="xref py py-class docutils literal"><span class="pre">DelimiterFraming</span></tt> stage which chops them up on newline characters.
The top-most stage then converts between <tt class="xref py py-class docutils literal"><span class="pre">String</span></tt> and UTF-8 encoded
<tt class="xref py py-class docutils literal"><span class="pre">ByteString</span></tt>.</p>
<p>As a result the pipeline will accept simple <tt class="xref py py-class docutils literal"><span class="pre">String</span></tt> commands, encode
them using UTF-8, delimit them with newlines (which are expected to be already
present in the sending direction), transform them into TCP commands and events,
encrypt them and send them off to the connection actor while buffering writes.</p>
<p>This pipeline is driven by a <tt class="xref py py-class docutils literal"><span class="pre">TcpPipelineHandler</span></tt> actor which is also
included in <tt class="docutils literal"><span class="pre">akka-actor</span></tt>. In order to capture the generic command and event
types consumed and emitted by that actor we need to create a wrapper—the nested
<tt class="xref py py-class docutils literal"><span class="pre">Init</span></tt> class—which also provides the the pipeline context needed by the
supplied pipeline; in this case we use the <tt class="xref py py-meth docutils literal"><span class="pre">withLogger</span></tt> convenience
method which supplies a context that implements <tt class="xref py py-class docutils literal"><span class="pre">HasLogger</span></tt> and
<tt class="xref py py-class docutils literal"><span class="pre">HasActorContext</span></tt> and should be sufficient for typical pipelines. With
those things bundled up all that remains is creating a
<tt class="xref py py-class docutils literal"><span class="pre">TcpPipelineHandler</span></tt> and registering that one as the recipient of
inbound traffic from the TCP connection.</p>
<p>Since we instructed that handler actor to send any events which are emitted by
the SSL pipeline to ourselves, we can then just wait for the reception of the
decrypted payload messages, compute a response—just <tt class="docutils literal"><span class="pre">&quot;world\n&quot;</span></tt> in this
case—and reply by sending back an <tt class="docutils literal"><span class="pre">Init.Command</span></tt>. It should be noted that
communication with the handler wraps commands and events in the inner types of
the <tt class="docutils literal"><span class="pre">init</span></tt> object in order to keep things well separated. To ease handling of
such path-dependent types there exist two helper methods, namely
<tt class="xref py py-class docutils literal"><span class="pre">Init.command</span></tt> for creating a command and <tt class="xref py py-class docutils literal"><span class="pre">Init.event</span></tt> for
unwrapping an event.</p>
<p>Looking at the client side we see that not much needs to be changed:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">public</span> <span class="k">class</span> <span class="nc">SslClient</span> <span class="k">extends</span> <span class="nc">UntypedActor</span> <span class="o">{</span>
  <span class="k">final</span> <span class="nc">InetSocketAddress</span> <span class="n">remote</span><span class="o">;</span>
  <span class="k">final</span> <span class="nc">SSLContext</span> <span class="n">sslContext</span><span class="o">;</span>
  <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">listener</span><span class="o">;</span>

  <span class="k">final</span> <span class="nc">LoggingAdapter</span> <span class="n">log</span> <span class="k">=</span> <span class="nc">Logging</span>
      <span class="o">.</span><span class="n">getLogger</span><span class="o">(</span><span class="n">getContext</span><span class="o">().</span><span class="n">system</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">());</span>

  <span class="n">public</span> <span class="nc">SslClient</span><span class="o">(</span><span class="nc">InetSocketAddress</span> <span class="n">remote</span><span class="o">,</span> <span class="nc">SSLContext</span> <span class="n">sslContext</span><span class="o">,</span> 
      <span class="nc">ActorRef</span> <span class="n">listener</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">remote</span> <span class="k">=</span> <span class="n">remote</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="n">sslContext</span> <span class="k">=</span> <span class="n">sslContext</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="n">listener</span> <span class="k">=</span> <span class="n">listener</span><span class="o">;</span>

    <span class="c1">// open a connection to the remote TCP port</span>
    <span class="nc">Tcp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">getContext</span><span class="o">().</span><span class="n">system</span><span class="o">()).</span><span class="n">getManager</span><span class="o">()</span>
        <span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="n">remote</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
  <span class="o">}</span>
  
  <span class="c1">// this will hold the pipeline handler’s context</span>
  <span class="nc">Init</span><span class="o">&lt;</span><span class="nc">WithinActorContext</span><span class="o">,</span> <span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">init</span> <span class="k">=</span> <span class="kc">null</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">onReceive</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">CommandFailed</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">getContext</span><span class="o">().</span><span class="n">stop</span><span class="o">(</span><span class="n">getSelf</span><span class="o">());</span>
      
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Connected</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// create a javax.net.ssl.SSLEngine for our peer in client mode</span>
      <span class="k">final</span> <span class="nc">SSLEngine</span> <span class="n">engine</span> <span class="k">=</span> <span class="n">sslContext</span><span class="o">.</span><span class="n">createSSLEngine</span><span class="o">(</span>
          <span class="n">remote</span><span class="o">.</span><span class="n">getHostName</span><span class="o">(),</span> <span class="n">remote</span><span class="o">.</span><span class="n">getPort</span><span class="o">());</span>
      <span class="n">engine</span><span class="o">.</span><span class="n">setUseClientMode</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

      <span class="c1">// build pipeline and set up context for communicating with TcpPipelineHandler</span>
      <span class="n">init</span> <span class="k">=</span> <span class="nc">TcpPipelineHandler</span><span class="o">.</span><span class="n">withLogger</span><span class="o">(</span><span class="n">log</span><span class="o">,</span> <span class="n">sequence</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span><span class="n">sequence</span><span class="o">(</span>
          <span class="k">new</span> <span class="nc">StringByteStringAdapter</span><span class="o">(</span><span class="s">&quot;utf-8&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">DelimiterFraming</span><span class="o">(</span><span class="mi">1024</span><span class="o">,</span> <span class="nc">ByteString</span><span class="o">.</span><span class="n">fromString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">),</span> <span class="kc">true</span><span class="o">)),</span>
          <span class="k">new</span> <span class="nc">TcpReadWriteAdapter</span><span class="o">()),</span>
          <span class="k">new</span> <span class="nc">SslTlsSupport</span><span class="o">(</span><span class="n">engine</span><span class="o">)),</span>
          <span class="k">new</span> <span class="nc">BackpressureBuffer</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="mi">10000</span><span class="o">,</span> <span class="mi">1000000</span><span class="o">)));</span>

      <span class="c1">// create handler for pipeline, setting ourselves as payload recipient</span>
      <span class="k">final</span> <span class="nc">ActorRef</span> <span class="n">handler</span> <span class="k">=</span> <span class="n">getContext</span><span class="o">().</span><span class="n">actorOf</span><span class="o">(</span>
          <span class="nc">TcpPipelineHandler</span><span class="o">.</span><span class="n">props</span><span class="o">(</span><span class="n">init</span><span class="o">,</span> <span class="n">getSender</span><span class="o">(),</span> <span class="n">getSelf</span><span class="o">()));</span>
      
      <span class="c1">// register the SSL handler with the connection</span>
      <span class="n">getSender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="nc">TcpMessage</span><span class="o">.</span><span class="n">register</span><span class="o">(</span><span class="n">handler</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
      
      <span class="c1">// and send a message across the SSL channel</span>
      <span class="n">handler</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="n">init</span><span class="o">.</span><span class="n">command</span><span class="o">(</span><span class="s">&quot;hello\n&quot;</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
    
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Init</span><span class="o">.</span><span class="nc">Event</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// unwrap TcpPipelineHandler’s event into a Tcp.Event</span>
      <span class="k">final</span> <span class="nc">String</span> <span class="n">recv</span> <span class="k">=</span> <span class="n">init</span><span class="o">.</span><span class="n">event</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
      <span class="c1">// and inform someone of the received payload</span>
      <span class="n">listener</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="n">recv</span><span class="o">,</span> <span class="n">getSelf</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Once the connection is established we again create a
<tt class="xref py py-class docutils literal"><span class="pre">TcpPipelineHandler</span></tt> wrapping an <tt class="xref py py-class docutils literal"><span class="pre">SslTlsSupport</span></tt> (in client mode)
and register that as the recipient of inbound traffic and ourselves as
recipient for the decrypted payload data. The we send a greeting to the server
and forward any replies to some <tt class="docutils literal"><span class="pre">listener</span></tt> actor.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The SslTlsSupport currently does not support using a <tt class="docutils literal"><span class="pre">Tcp.WriteCommand</span></tt>
other than <tt class="docutils literal"><span class="pre">Tcp.Write</span></tt>, like for example <tt class="docutils literal"><span class="pre">Tcp.WriteFile</span></tt>. It also doesn't
support messages that are larger than the size of the send buffer on the socket.
Trying to send such a message will result in a <tt class="docutils literal"><span class="pre">CommandFailed</span></tt>. If you need
to send large messages over SSL, then they have to be sent in chunks.</p>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://akka.io/faq">FAQ</a></li>
      <li><a href="http://typesafe.com/stack/downloads/akka">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>      
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>      
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://typesafe.com/products/typesafe-subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@typesafe.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/watermark.png" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2013 <a href="http://typesafe.com/">Typesafe Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Oct 23, 2013
    </p>          
  </div>
</div>
<script src="http://www.google.com/jsapi" type="text/javascript"></script>
<script type="text/javascript">
    google.load('search', '1', {language : 'en', style : google.loader.themes.MINIMALIST});
    google.setOnLoadCallback(function() {
    var customSearchOptions = {};  var customSearchControl = new google.search.CustomSearchControl(
    '003065520604945464838:izzukx8-qba', customSearchOptions);
    customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
    customSearchControl.draw('cse');
    var path = window.location.pathname.split('/').slice(0,4);
    if(window.location.hostname && path.length >= 4) {
    var site = "site:" + window.location.hostname + path.join('/').toString();
    customSearchControl.setSearchStartingCallback(this, function(c, s, q) { s.setQueryAddition(site); });
    }
    }, true);
</script>
<style type="text/css">
    .gsc-control-cse {
    font-family: Arial, sans-serif;
    border-color: rgb(242, 242, 235);
    background-color: rgb(242, 242, 235);
    }
    .gsc-control-cse .gsc-table-result {
      font-family: Arial, sans-serif;
      display: block;
    }
    input.gsc-input {
    border-color: #BBBBBB;
    }
    input.gsc-search-button {
    border-color: rgb(34, 57, 64);
    background-color: rgb(68, 114, 129);
    color: #FFFFFF;
    }
    .gsc-tabHeader.gsc-tabhInactive {
    border-color: #777777;
    background-color: #777777;
    }
    .gsc-tabHeader.gsc-tabhActive {
    border-color: #333333;
    background-color: #333333;
    }
    .gsc-tabsArea {
    border-color: #333333;
    }
    .gsc-webResult.gsc-result,
    .gsc-results .gsc-imageResult {
      border-color: #666666;
      background-color: #FFFFFF;
      padding: 0.5em 0.5em;
    }
    .gsc-webResult.gsc-result:hover,
    .gsc-imageResult:hover {
      border-color: #AAAAAA;
      background-color: #FFFFFF;
      padding: 0.5em 0.5em;
    }
    .gsc-webResult.gsc-result.gsc-promotion:hover {
    border-color: #AAAAAA;
    background-color: #FFFFFF;
    }
    .gs-webResult.gs-result a.gs-title:link,
    .gs-webResult.gs-result a.gs-title:link b,
    .gs-imageResult a.gs-title:link,
    .gs-imageResult a.gs-title:link b {
    color: #444444;
    }
    .gs-webResult.gs-result a.gs-title:visited,
    .gs-webResult.gs-result a.gs-title:visited b,
    .gs-imageResult a.gs-title:visited,
    .gs-imageResult a.gs-title:visited b {
    color: #444444;
    }
    .gs-webResult.gs-result a.gs-title:hover,
    .gs-webResult.gs-result a.gs-title:hover b,
    .gs-imageResult a.gs-title:hover,
    .gs-imageResult a.gs-title:hover b {
    color: #444444;
    }
    .gs-webResult.gs-result a.gs-title:active,
    .gs-webResult.gs-result a.gs-title:active b,
    .gs-imageResult a.gs-title:active,
    .gs-imageResult a.gs-title:active b {
    color: #777777;
    }
    .gsc-cursor-page {
    color: #444444;
    }
    a.gsc-trailing-more-results:link {
    color: #444444;
    }
    .gs-webResult .gs-snippet,
    .gs-imageResult .gs-snippet,
    .gs-fileFormatType {
    color: #333333;
    }
    .gs-webResult div.gs-visibleUrl,
    .gs-imageResult div.gs-visibleUrl {
    color: #000000;
    }
    .gs-webResult div.gs-visibleUrl-short {
    color: #000000;
    }
    .gs-webResult div.gs-visibleUrl-short {
    display: none;
    }
    .gs-webResult div.gs-visibleUrl-long {
    display: block;
    }
    .gs-promotion div.gs-visibleUrl-short {
    display: none;
    }
    .gs-promotion div.gs-visibleUrl-long {
    display: block;
    }
    .gsc-cursor-box {
    border-color: #FFFFFF;
    }
    .gsc-results .gsc-cursor-box .gsc-cursor-page {
    border-color: #777777;
    background-color: #FFFFFF;
    color: #444444;
    }
    .gsc-results .gsc-cursor-box .gsc-cursor-current-page {
    border-color: #333333;
    background-color: #333333;
    color: #444444;
    }
    .gsc-webResult.gsc-result.gsc-promotion {
    border-color: #CCCCCC;
    background-color: #E6E6E6;
    }
    .gsc-completion-title {
    color: #444444;
    }
    .gsc-completion-snippet {
    color: #333333;
    }
    .gs-promotion a.gs-title:link,
    .gs-promotion a.gs-title:link *,
    .gs-promotion .gs-snippet a:link {
    color: #0000CC;
    }
    .gs-promotion a.gs-title:visited,
    .gs-promotion a.gs-title:visited *,
    .gs-promotion .gs-snippet a:visited {
    color: #0000CC;
    }
    .gs-promotion a.gs-title:hover,
    .gs-promotion a.gs-title:hover *,
    .gs-promotion .gs-snippet a:hover {
    color: #444444;
    }
    .gs-promotion a.gs-title:active,
    .gs-promotion a.gs-title:active *,
    .gs-promotion .gs-snippet a:active {
    color: #00CC00;
    }
    .gs-promotion .gs-snippet,
    .gs-promotion .gs-title .gs-promotion-title-right,
    .gs-promotion .gs-title .gs-promotion-title-right *  {
    color: #333333;
    }
    .gs-promotion .gs-visibleUrl,
    .gs-promotion .gs-visibleUrl-short {
    color: #00CC00;
    }
</style>
<script type="text/javascript">
  $('#toc').toc();
</script>
  

  </body>
</html>