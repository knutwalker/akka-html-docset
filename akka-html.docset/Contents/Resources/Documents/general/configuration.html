

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Configuration &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Exo:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="General" href="index.html" />
    <link rel="next" title="Actors" href="../scala/index-actors.html" />
    <link rel="prev" title="Message Delivery Guarantees" href="message-delivery-guarantees.html" />

  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img src="../_static/logo-small.png" /></a>
        </div>    
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://akka.io/faq">FAQ</a></li>
          <li><a href="http://typesafe.com/stack/downloads/akka">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>           
          <li><a href="http://typesafe.com/products/typesafe-subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Configuration</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">           
              <li>
                 <span class="divider">|</span> <a href="../scala/index-actors.html">Actors</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../index.html">Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="message-delivery-guarantees.html">Message Delivery Guarantees</a> <span class="divider">|</span>
              </li>
              <li>
                Version 2.2.3
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="configuration">
<span id="id1"></span><h1>Configuration</h1>
<p>You can start using Akka without defining any configuration, since sensible default values
are provided. Later on you might need to amend the settings to change the default behavior
or adapt for specific runtime environments. Typical examples of settings that you
might amend:</p>
<ul class="simple">
<li>log level and logger backend</li>
<li>enable remoting</li>
<li>message serializers</li>
<li>definition of routers</li>
<li>tuning of dispatchers</li>
</ul>
<p>Akka uses the <a class="reference external" href="https://github.com/typesafehub/config">Typesafe Config Library</a>, which might also be a good choice
for the configuration of your own application or library built with or without
Akka. This library is implemented in Java with no external dependencies; you
should have a look at its documentation (in particular about <a class="reference external" href="http://typesafehub.github.com/config/latest/api/com/typesafe/config/ConfigFactory.html">ConfigFactory</a>),
which is only summarized in the following.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If you use Akka from the Scala REPL from the 2.9.x series,
and you do not provide your own ClassLoader to the ActorSystem,
start the REPL with &quot;-Yrepl-sync&quot; to work around a deficiency in
the REPLs provided Context ClassLoader.</p>
</div>
<div class="section" id="where-configuration-is-read-from">
<h2>Where configuration is read from</h2>
<p>All configuration for Akka is held within instances of <tt class="xref py py-class docutils literal"><span class="pre">ActorSystem</span></tt>, or
put differently, as viewed from the outside, <tt class="xref py py-class docutils literal"><span class="pre">ActorSystem</span></tt> is the only
consumer of configuration information. While constructing an actor system, you
can either pass in a <tt class="xref py py-class docutils literal"><span class="pre">Config</span></tt> object or not, where the second case is
equivalent to passing <tt class="docutils literal"><span class="pre">ConfigFactory.load()</span></tt> (with the right class loader).
This means roughly that the default is to parse all <tt class="docutils literal"><span class="pre">application.conf</span></tt>,
<tt class="docutils literal"><span class="pre">application.json</span></tt> and <tt class="docutils literal"><span class="pre">application.properties</span></tt> found at the root of the
class path—please refer to the aforementioned documentation for details. The
actor system then merges in all <tt class="docutils literal"><span class="pre">reference.conf</span></tt> resources found at the root
of the class path to form the fallback configuration, i.e. it internally uses</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">appConfig</span><span class="o">.</span><span class="n">withFallback</span><span class="o">(</span><span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">defaultReference</span><span class="o">(</span><span class="n">classLoader</span><span class="o">))</span>
</pre></div>
</div>
<p>The philosophy is that code never contains default values, but instead relies
upon their presence in the <tt class="docutils literal"><span class="pre">reference.conf</span></tt> supplied with the library in
question.</p>
<p>Highest precedence is given to overrides given as system properties, see <a class="reference external" href="https://github.com/typesafehub/config/blob/master/HOCON.md">the
HOCON specification</a> (near the
bottom). Also noteworthy is that the application configuration—which defaults
to <tt class="docutils literal"><span class="pre">application</span></tt>—may be overridden using the <tt class="docutils literal"><span class="pre">config.resource</span></tt> property
(there are more, please refer to the <a class="reference external" href="https://github.com/typesafehub/config/blob/master/README.md">Config docs</a>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you are writing an Akka application, keep you configuration in
<tt class="docutils literal"><span class="pre">application.conf</span></tt> at the root of the class path. If you are writing an
Akka-based library, keep its configuration in <tt class="docutils literal"><span class="pre">reference.conf</span></tt> at the root
of the JAR file.</p>
</div>
</div>
<div class="section" id="when-using-jarjar-onejar-assembly-or-any-jar-bundler">
<h2>When using JarJar, OneJar, Assembly or any jar-bundler</h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Akka's configuration approach relies heavily on the notion of every
module/jar having its own reference.conf file, all of these will be
discovered by the configuration and loaded. Unfortunately this also means
that if you put/merge multiple jars into the same jar, you need to merge all the
reference.confs as well. Otherwise all defaults will be lost and Akka will not function.</p>
</div>
</div>
<div class="section" id="custom-application-conf">
<h2>Custom application.conf</h2>
<p>A custom <tt class="docutils literal"><span class="pre">application.conf</span></tt> might look like this:</p>
<div class="highlight-scala"><div class="highlight"><pre># In this file you can override any option defined in the reference files.
# Copy in parts of the reference files and modify as you please.

akka {

  # Loggers to register at boot time (akka.event.Logging$DefaultLogger logs
  # to STDOUT)
  loggers = [&quot;akka.event.slf4j.Slf4jLogger&quot;]

  # Log level used by the configured loggers (see &quot;loggers&quot;) as soon
  # as they have been started; before that, see &quot;stdout-loglevel&quot;
  # Options: OFF, ERROR, WARNING, INFO, DEBUG
  loglevel = &quot;DEBUG&quot;

  # Log level for the very basic logger activated during AkkaApplication startup
  # Options: OFF, ERROR, WARNING, INFO, DEBUG
  stdout-loglevel = &quot;DEBUG&quot;

  actor {
    default-dispatcher {
      # Throughput for default Dispatcher, set to 1 for as fair as possible
      throughput = 10
    }
  }

  remote {
    server {
      # The port clients should connect to. Default is 2552 (AKKA)
      port = 2562
    }
  }
}
</pre></div>
</div>
</div>
<div class="section" id="including-files">
<h2>Including files</h2>
<p>Sometimes it can be useful to include another configuration file, for example if you have one <tt class="docutils literal"><span class="pre">application.conf</span></tt> with all
environment independent settings and then override some settings for specific environments.</p>
<p>Specifying system property with <tt class="docutils literal"><span class="pre">-Dconfig.resource=/dev.conf</span></tt> will load the <tt class="docutils literal"><span class="pre">dev.conf</span></tt> file, which includes the <tt class="docutils literal"><span class="pre">application.conf</span></tt></p>
<p>dev.conf:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">include</span> <span class="s">&quot;application&quot;</span>

<span class="n">akka</span> <span class="o">{</span>
  <span class="n">loglevel</span> <span class="k">=</span> <span class="s">&quot;DEBUG&quot;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>More advanced include and substitution mechanisms are explained in the <a class="reference external" href="https://github.com/typesafehub/config/blob/master/HOCON.md">HOCON</a>
specification.</p>
</div>
<div class="section" id="logging-of-configuration">
<span id="dakka-log-config-on-start"></span><h2>Logging of Configuration</h2>
<p>If the system or config property <tt class="docutils literal"><span class="pre">akka.log-config-on-start</span></tt> is set to <tt class="docutils literal"><span class="pre">on</span></tt>, then the
complete configuration at INFO level when the actor system is started. This is useful
when you are uncertain of what configuration is used.</p>
<p>If in doubt, you can also easily and nicely inspect configuration objects
before or after using them to construct an actor system:</p>
<div class="highlight-scala"><div class="highlight"><pre>Welcome to Scala version 2.10.2 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_27).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import com.typesafe.config._
import com.typesafe.config._

scala&gt; ConfigFactory.parseString(&quot;a.b=12&quot;)
res0: com.typesafe.config.Config = Config(SimpleConfigObject({&quot;a&quot; : {&quot;b&quot; : 12}}))

scala&gt; res0.root.render
res1: java.lang.String =
{
    # String: 1
    &quot;a&quot; : {
        # String: 1
        &quot;b&quot; : 12
    }
}
</pre></div>
</div>
<p>The comments preceding every item give detailed information about the origin of
the setting (file &amp; line number) plus possible comments which were present,
e.g. in the reference configuration. The settings as merged with the reference
and parsed by the actor system can be displayed like this:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">final</span> <span class="n">ActorSystem</span> <span class="n">system</span> <span class="o">=</span> <span class="n">ActorSystem</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">system</span><span class="o">.</span><span class="na">settings</span><span class="o">());</span>
<span class="c1">// this is a shortcut for system.settings().config().root().render()</span>
</pre></div>
</div>
</div>
<div class="section" id="a-word-about-classloaders">
<h2>A Word About ClassLoaders</h2>
<p>In several places of the configuration file it is possible to specify the
fully-qualified class name of something to be instantiated by Akka. This is
done using Java reflection, which in turn uses a <tt class="xref py py-class docutils literal"><span class="pre">ClassLoader</span></tt>. Getting
the right one in challenging environments like application containers or OSGi
bundles is not always trivial, the current approach of Akka is that each
<tt class="xref py py-class docutils literal"><span class="pre">ActorSystem</span></tt> implementation stores the current thread’s context class
loader (if available, otherwise just its own loader as in
<tt class="docutils literal"><span class="pre">this.getClass.getClassLoader</span></tt>) and uses that for all reflective accesses.
This implies that putting Akka on the boot class path will yield
<tt class="xref py py-class docutils literal"><span class="pre">NullPointerException</span></tt> from strange places: this is simply not
supported.</p>
</div>
<div class="section" id="application-specific-settings">
<h2>Application specific settings</h2>
<p>The configuration can also be used for application specific settings.
A good practice is to place those settings in an Extension, as described in:</p>
<blockquote>
<div><ul class="simple">
<li>Scala API: <a class="reference internal" href="../scala/extending-akka.html#extending-akka-scala-settings"><em>Application specific settings</em></a></li>
<li>Java API: <a class="reference internal" href="../java/extending-akka.html#extending-akka-java-settings"><em>Application specific settings</em></a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="configuring-multiple-actorsystem">
<h2>Configuring multiple ActorSystem</h2>
<p>If you have more than one <tt class="docutils literal"><span class="pre">ActorSystem</span></tt> (or you're writing a
library and have an <tt class="docutils literal"><span class="pre">ActorSystem</span></tt> that may be separate from the
application's) you may want to separate the configuration for each
system.</p>
<p>Given that <tt class="docutils literal"><span class="pre">ConfigFactory.load()</span></tt> merges all resources with matching name
from the whole class path, it is easiest to utilize that functionality and
differentiate actor systems within the hierarchy of the configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">myapp1</span> <span class="o">{</span>
  <span class="n">akka</span><span class="o">.</span><span class="n">loglevel</span> <span class="k">=</span> <span class="s">&quot;WARNING&quot;</span>
  <span class="n">my</span><span class="o">.</span><span class="n">own</span><span class="o">.</span><span class="n">setting</span> <span class="k">=</span> <span class="mi">43</span>
<span class="o">}</span>
<span class="n">myapp2</span> <span class="o">{</span>
  <span class="n">akka</span><span class="o">.</span><span class="n">loglevel</span> <span class="k">=</span> <span class="s">&quot;ERROR&quot;</span>
  <span class="n">app2</span><span class="o">.</span><span class="n">setting</span> <span class="k">=</span> <span class="s">&quot;appname&quot;</span>
<span class="o">}</span>
<span class="n">my</span><span class="o">.</span><span class="n">own</span><span class="o">.</span><span class="n">setting</span> <span class="k">=</span> <span class="mi">42</span>
<span class="n">my</span><span class="o">.</span><span class="n">other</span><span class="o">.</span><span class="n">setting</span> <span class="k">=</span> <span class="s">&quot;hello&quot;</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">config</span> <span class="k">=</span> <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">load</span><span class="o">()</span>
<span class="k">val</span> <span class="n">app1</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;MyApp1&quot;</span><span class="o">,</span> <span class="n">config</span><span class="o">.</span><span class="n">getConfig</span><span class="o">(</span><span class="s">&quot;myapp1&quot;</span><span class="o">).</span><span class="n">withFallback</span><span class="o">(</span><span class="n">config</span><span class="o">))</span>
<span class="k">val</span> <span class="n">app2</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;MyApp2&quot;</span><span class="o">,</span>
  <span class="n">config</span><span class="o">.</span><span class="n">getConfig</span><span class="o">(</span><span class="s">&quot;myapp2&quot;</span><span class="o">).</span><span class="n">withOnlyPath</span><span class="o">(</span><span class="s">&quot;akka&quot;</span><span class="o">).</span><span class="n">withFallback</span><span class="o">(</span><span class="n">config</span><span class="o">))</span>
</pre></div>
</div>
<p>These two samples demonstrate different variations of the “lift-a-subtree”
trick: in the first case, the configuration accessible from within the actor
system is this</p>
<div class="highlight-ruby"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">loglevel</span> <span class="o">=</span> <span class="s2">&quot;WARNING&quot;</span>
<span class="n">my</span><span class="o">.</span><span class="n">own</span><span class="o">.</span><span class="n">setting</span> <span class="o">=</span> <span class="mi">43</span>
<span class="n">my</span><span class="o">.</span><span class="n">other</span><span class="o">.</span><span class="n">setting</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span>
<span class="sr">//</span> <span class="n">plus</span> <span class="n">myapp1</span> <span class="ow">and</span> <span class="n">myapp2</span> <span class="n">subtrees</span>
</pre></div>
</div>
<p>while in the second one, only the “akka” subtree is lifted, with the following
result</p>
<div class="highlight-ruby"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">loglevel</span> <span class="o">=</span> <span class="s2">&quot;ERROR&quot;</span>
<span class="n">my</span><span class="o">.</span><span class="n">own</span><span class="o">.</span><span class="n">setting</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">my</span><span class="o">.</span><span class="n">other</span><span class="o">.</span><span class="n">setting</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span>
<span class="sr">//</span> <span class="n">plus</span> <span class="n">myapp1</span> <span class="ow">and</span> <span class="n">myapp2</span> <span class="n">subtrees</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The configuration library is really powerful, explaining all features exceeds
the scope affordable here. In particular not covered are how to include other
configuration files within other files (see a small example at <a class="reference internal" href="#including-files">Including
files</a>) and copying parts of the configuration tree by way of path
substitutions.</p>
</div>
<p>You may also specify and parse the configuration programmatically in other ways when instantiating
the <tt class="docutils literal"><span class="pre">ActorSystem</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">com.typesafe.config.ConfigFactory</span>
    <span class="k">val</span> <span class="n">customConf</span> <span class="k">=</span> <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">parseString</span><span class="o">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">      akka.actor.deployment {</span>
<span class="s">        /my-service {</span>
<span class="s">          router = round-robin</span>
<span class="s">          nr-of-instances = 3</span>
<span class="s">        }</span>
<span class="s">      }</span>
<span class="s">      &quot;&quot;&quot;</span><span class="o">)</span>
    <span class="c1">// ConfigFactory.load sandwiches customConfig between default reference</span>
    <span class="c1">// config and default overrides, and then resolves it.</span>
    <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;MySystem&quot;</span><span class="o">,</span> <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">load</span><span class="o">(</span><span class="n">customConf</span><span class="o">))</span>
</pre></div>
</div>
</div>
<div class="section" id="reading-configuration-from-a-custom-location">
<h2>Reading configuration from a custom location</h2>
<p>You can replace or supplement <tt class="docutils literal"><span class="pre">application.conf</span></tt> either in code
or using system properties.</p>
<p>If you're using <tt class="docutils literal"><span class="pre">ConfigFactory.load()</span></tt> (which Akka does by
default) you can replace <tt class="docutils literal"><span class="pre">application.conf</span></tt> by defining
<tt class="docutils literal"><span class="pre">-Dconfig.resource=whatever</span></tt>, <tt class="docutils literal"><span class="pre">-Dconfig.file=whatever</span></tt>, or
<tt class="docutils literal"><span class="pre">-Dconfig.url=whatever</span></tt>.</p>
<p>From inside your replacement file specified with
<tt class="docutils literal"><span class="pre">-Dconfig.resource</span></tt> and friends, you can <tt class="docutils literal"><span class="pre">include</span>
<span class="pre">&quot;application&quot;</span></tt> if you still want to use
<tt class="docutils literal"><span class="pre">application.{conf,json,properties}</span></tt> as well.  Settings
specified before <tt class="docutils literal"><span class="pre">include</span> <span class="pre">&quot;application&quot;</span></tt> would be overridden by
the included file, while those after would override the included
file.</p>
<p>In code, there are many customization options.</p>
<p>There are several overloads of <tt class="docutils literal"><span class="pre">ConfigFactory.load()</span></tt>; these
allow you to specify something to be sandwiched between system
properties (which override) and the defaults (from
<tt class="docutils literal"><span class="pre">reference.conf</span></tt>), replacing the usual
<tt class="docutils literal"><span class="pre">application.{conf,json,properties}</span></tt> and replacing
<tt class="docutils literal"><span class="pre">-Dconfig.file</span></tt> and friends.</p>
<p>The simplest variant of <tt class="docutils literal"><span class="pre">ConfigFactory.load()</span></tt> takes a resource
basename (instead of <tt class="docutils literal"><span class="pre">application</span></tt>); <tt class="docutils literal"><span class="pre">myname.conf</span></tt>,
<tt class="docutils literal"><span class="pre">myname.json</span></tt>, and <tt class="docutils literal"><span class="pre">myname.properties</span></tt> would then be used
instead of <tt class="docutils literal"><span class="pre">application.{conf,json,properties}</span></tt>.</p>
<p>The most flexible variant takes a <tt class="docutils literal"><span class="pre">Config</span></tt> object, which
you can load using any method in <tt class="docutils literal"><span class="pre">ConfigFactory</span></tt>.  For example
you could put a config string in code using
<tt class="docutils literal"><span class="pre">ConfigFactory.parseString()</span></tt> or you could make a map and
<tt class="docutils literal"><span class="pre">ConfigFactory.parseMap()</span></tt>, or you could load a file.</p>
<p>You can also combine your custom config with the usual config,
that might look like:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// make a Config with just your special setting</span>
<span class="nc">Config</span> <span class="n">myConfig</span> <span class="k">=</span>
  <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">parseString</span><span class="o">(</span><span class="s">&quot;something=somethingElse&quot;</span><span class="o">);</span>
<span class="c1">// load the normal config stack (system props,</span>
<span class="c1">// then application.conf, then reference.conf)</span>
<span class="nc">Config</span> <span class="n">regularConfig</span> <span class="k">=</span>
  <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">load</span><span class="o">();</span>
<span class="c1">// override regular stack with myConfig</span>
<span class="nc">Config</span> <span class="n">combined</span> <span class="k">=</span>
  <span class="n">myConfig</span><span class="o">.</span><span class="n">withFallback</span><span class="o">(</span><span class="n">regularConfig</span><span class="o">);</span>
<span class="c1">// put the result in between the overrides</span>
<span class="c1">// (system props) and defaults again</span>
<span class="nc">Config</span> <span class="n">complete</span> <span class="k">=</span>
  <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">load</span><span class="o">(</span><span class="n">combined</span><span class="o">);</span>
<span class="c1">// create ActorSystem</span>
<span class="nc">ActorSystem</span> <span class="n">system</span> <span class="k">=</span>
  <span class="nc">ActorSystem</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;myname&quot;</span><span class="o">,</span> <span class="n">complete</span><span class="o">);</span>
</pre></div>
</div>
<p>When working with <tt class="docutils literal"><span class="pre">Config</span></tt> objects, keep in mind that there are
three &quot;layers&quot; in the cake:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">ConfigFactory.defaultOverrides()</span></tt> (system properties)</li>
<li>the app's settings</li>
<li><tt class="docutils literal"><span class="pre">ConfigFactory.defaultReference()</span></tt> (reference.conf)</li>
</ul>
</div></blockquote>
<p>The normal goal is to customize the middle layer while leaving the
other two alone.</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">ConfigFactory.load()</span></tt> loads the whole stack</li>
<li>the overloads of <tt class="docutils literal"><span class="pre">ConfigFactory.load()</span></tt> let you specify a
different middle layer</li>
<li>the <tt class="docutils literal"><span class="pre">ConfigFactory.parse()</span></tt> variations load single files or resources</li>
</ul>
</div></blockquote>
<p>To stack two layers, use <tt class="docutils literal"><span class="pre">override.withFallback(fallback)</span></tt>; try
to keep system props (<tt class="docutils literal"><span class="pre">defaultOverrides()</span></tt>) on top and
<tt class="docutils literal"><span class="pre">reference.conf</span></tt> (<tt class="docutils literal"><span class="pre">defaultReference()</span></tt>) on the bottom.</p>
<p>Do keep in mind, you can often just add another <tt class="docutils literal"><span class="pre">include</span></tt>
statement in <tt class="docutils literal"><span class="pre">application.conf</span></tt> rather than writing code.
Includes at the top of <tt class="docutils literal"><span class="pre">application.conf</span></tt> will be overridden by
the rest of <tt class="docutils literal"><span class="pre">application.conf</span></tt>, while those at the bottom will
override the earlier stuff.</p>
</div>
<div class="section" id="listing-of-the-reference-configuration">
<h2>Listing of the Reference Configuration</h2>
<p>Each Akka module has a reference configuration file with the default values.</p>
<div class="section" id="akka-actor">
<h3>akka-actor</h3>
<div class="highlight-none"><div class="highlight"><pre>####################################
# Akka Actor Reference Config File #
####################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {
  # Akka version, checked against the runtime version of Akka.
  version = &quot;2.2.3&quot;

  # Home directory of Akka, modules in the deploy directory will be loaded
  home = &quot;&quot;

  # Loggers to register at boot time (akka.event.Logging$DefaultLogger logs
  # to STDOUT)
  loggers = [&quot;akka.event.Logging$DefaultLogger&quot;]

  # Deprecated, use akka.loggers.
  event-handlers = []

  # Loggers are created and registered synchronously during ActorSystem
  # start-up, and since they are actors, this timeout is used to bound the
  # waiting time
  logger-startup-timeout = 5s

  # Deprecated, use akka.logger-startup-timeout
  event-handler-startup-timeout = -1s

  # Log level used by the configured loggers (see &quot;loggers&quot;) as soon
  # as they have been started; before that, see &quot;stdout-loglevel&quot;
  # Options: OFF, ERROR, WARNING, INFO, DEBUG
  loglevel = &quot;INFO&quot;

  # Log level for the very basic logger activated during AkkaApplication startup
  # Options: OFF, ERROR, WARNING, INFO, DEBUG
  stdout-loglevel = &quot;WARNING&quot;

  # Log the complete configuration at INFO level when the actor system is started.
  # This is useful when you are uncertain of what configuration is used.
  log-config-on-start = off

  # Log at info level when messages are sent to dead letters.
  # Possible values:
  # on: all dead letters are logged
  # off: no logging of dead letters
  # n: positive integer, number of dead letters that will be logged
  log-dead-letters = 10

  # Possibility to turn off logging of dead letters while the actor system
  # is shutting down. Logging is only done when enabled by &#39;log-dead-letters&#39;
  # setting.
  log-dead-letters-during-shutdown = on

  # List FQCN of extensions which shall be loaded at actor system startup.
  # Should be on the format: &#39;extensions = [&quot;foo&quot;, &quot;bar&quot;]&#39; etc.
  # See the Akka Documentation for more info about Extensions
  extensions = []

  # Toggles whether threads created by this ActorSystem should be daemons or not
  daemonic = off

  # JVM shutdown, System.exit(-1), in case of a fatal error,
  # such as OutOfMemoryError
  jvm-exit-on-fatal-error = on

  actor {

    # FQCN of the ActorRefProvider to be used; the below is the built-in default,
    # another one is akka.remote.RemoteActorRefProvider in the akka-remote bundle.
    provider = &quot;akka.actor.LocalActorRefProvider&quot;

    # The guardian &quot;/user&quot; will use this class to obtain its supervisorStrategy.
    # It needs to be a subclass of akka.actor.SupervisorStrategyConfigurator.
    # In addition to the default there is akka.actor.StoppingSupervisorStrategy.
    guardian-supervisor-strategy = &quot;akka.actor.DefaultSupervisorStrategy&quot;

    # Timeout for ActorSystem.actorOf
    creation-timeout = 20s

    # Frequency with which stopping actors are prodded in case they had to be
    # removed from their parents
    reaper-interval = 5s

    # Serializes and deserializes (non-primitive) messages to ensure immutability,
    # this is only intended for testing.
    serialize-messages = off

    # Serializes and deserializes creators (in Props) to ensure that they can be
    # sent over the network, this is only intended for testing. Purely local deployments
    # as marked with deploy.scope == LocalScope are exempt from verification.
    serialize-creators = off

    # Timeout for send operations to top-level actors which are in the process
    # of being started. This is only relevant if using a bounded mailbox or the
    # CallingThreadDispatcher for a top-level actor.
    unstarted-push-timeout = 10s

    typed {
      # Default timeout for typed actor methods with non-void return type
      timeout = 5s
    }

    deployment {

      # deployment id pattern - on the format: /parent/child etc.
      default {

        # The id of the dispatcher to use for this actor.
        # If undefined or empty the dispatcher specified in code
        # (Props.withDispatcher) is used, or default-dispatcher if not
        # specified at all.
        dispatcher = &quot;&quot;

        # The id of the mailbox to use for this actor.
        # If undefined or empty the default mailbox of the configured dispatcher
        # is used or if there is no mailbox configuration the mailbox specified
        # in code (Props.withMailbox) is used.
        # If there is a mailbox defined in the configured dispatcher then that
        # overrides this setting.
        mailbox = &quot;&quot;

        # routing (load-balance) scheme to use
        # - available: &quot;from-code&quot;, &quot;round-robin&quot;, &quot;random&quot;, &quot;smallest-mailbox&quot;,
        #              &quot;scatter-gather&quot;, &quot;broadcast&quot;
        # - or:        Fully qualified class name of the router class.
        #              The class must extend akka.routing.CustomRouterConfig and
        #              have a public constructor with com.typesafe.config.Config
        #              parameter.
        # - default is &quot;from-code&quot;;
        # Whether or not an actor is transformed to a Router is decided in code
        # only (Props.withRouter). The type of router can be overridden in the
        # configuration; specifying &quot;from-code&quot; means that the values specified
        # in the code shall be used.
        # In case of routing, the actors to be routed to can be specified
        # in several ways:
        # - nr-of-instances: will create that many children
        # - routees.paths: will look the paths up using actorFor and route to
        #   them, i.e. will not create children
        # - resizer: dynamically resizable number of routees as specified in
        #   resizer below
        router = &quot;from-code&quot;

        # number of children to create in case of a router;
        # this setting is ignored if routees.paths is given
        nr-of-instances = 1

        # within is the timeout used for routers containing future calls
        within = 5 seconds

        # number of virtual nodes per node for consistent-hashing router
        virtual-nodes-factor = 10

        routees {
          # Alternatively to giving nr-of-instances you can specify the full
          # paths of those actors which should be routed to. This setting takes
          # precedence over nr-of-instances
          paths = []
        }

        # Routers with dynamically resizable number of routees; this feature is
        # enabled by including (parts of) this section in the deployment
        resizer {

          # The fewest number of routees the router should ever have.
          lower-bound = 1

          # The most number of routees the router should ever have.
          # Must be greater than or equal to lower-bound.
          upper-bound = 10

          # Threshold used to evaluate if a routee is considered to be busy
          # (under pressure). Implementation depends on this value (default is 1).
          # 0:   number of routees currently processing a message.
          # 1:   number of routees currently processing a message has
          #      some messages in mailbox.
          # &gt; 1: number of routees with at least the configured pressure-threshold
          #      messages in their mailbox. Note that estimating mailbox size of
          #      default UnboundedMailbox is O(N) operation.
          pressure-threshold = 1

          # Percentage to increase capacity whenever all routees are busy.
          # For example, 0.2 would increase 20% (rounded up), i.e. if current
          # capacity is 6 it will request an increase of 2 more routees.
          rampup-rate = 0.2

          # Minimum fraction of busy routees before backing off.
          # For example, if this is 0.3, then we&#39;ll remove some routees only when
          # less than 30% of routees are busy, i.e. if current capacity is 10 and
          # 3 are busy then the capacity is unchanged, but if 2 or less are busy
          # the capacity is decreased.
          # Use 0.0 or negative to avoid removal of routees.
          backoff-threshold = 0.3

          # Fraction of routees to be removed when the resizer reaches the
          # backoffThreshold.
          # For example, 0.1 would decrease 10% (rounded up), i.e. if current
          # capacity is 9 it will request an decrease of 1 routee.
          backoff-rate = 0.1

          # When the resizer reduce the capacity the abandoned routee actors are
          # stopped with PoisonPill after this delay. The reason for the delay is
          # to give concurrent messages a chance to be placed in mailbox before
          # sending PoisonPill.
          # Use 0s to skip delay.
          stop-delay = 1s

          # Number of messages between resize operation.
          # Use 1 to resize before each message.
          messages-per-resize = 10
        }
      }
    }

    default-dispatcher {
      # Must be one of the following
      # Dispatcher, (BalancingDispatcher, only valid when all actors using it are
      # of the same type), PinnedDispatcher, or a FQCN to a class inheriting
      # MessageDispatcherConfigurator with a public constructor with
      # both com.typesafe.config.Config parameter and
      # akka.dispatch.DispatcherPrerequisites parameters.
      # PinnedDispatcher must be used toghether with executor=thread-pool-executor.
      type = &quot;Dispatcher&quot;

      # Which kind of ExecutorService to use for this dispatcher
      # Valid options:
      #  - &quot;fork-join-executor&quot; requires a &quot;fork-join-executor&quot; section
      #  - &quot;thread-pool-executor&quot; requires a &quot;thread-pool-executor&quot; section
      #  - A FQCN of a class extending ExecutorServiceConfigurator
      executor = &quot;fork-join-executor&quot;

      # This will be used if you have set &quot;executor = &quot;fork-join-executor&quot;&quot;
      fork-join-executor {
        # Min number of threads to cap factor-based parallelism number to
        parallelism-min = 8

        # The parallelism factor is used to determine thread pool size using the
        # following formula: ceil(available processors * factor). Resulting size
        # is then bounded by the parallelism-min and parallelism-max values.
        parallelism-factor = 3.0

        # Max number of threads to cap factor-based parallelism number to
        parallelism-max = 64
      }

      # This will be used if you have set &quot;executor = &quot;thread-pool-executor&quot;&quot;
      thread-pool-executor {
        # Keep alive time for threads
        keep-alive-time = 60s

        # Min number of threads to cap factor-based core number to
        core-pool-size-min = 8

        # The core pool size factor is used to determine thread pool core size
        # using the following formula: ceil(available processors * factor).
        # Resulting size is then bounded by the core-pool-size-min and
        # core-pool-size-max values.
        core-pool-size-factor = 3.0

        # Max number of threads to cap factor-based number to
        core-pool-size-max = 64

        # Minimum number of threads to cap factor-based max number to
        # (if using a bounded task queue)
        max-pool-size-min = 8

        # Max no of threads (if using a bounded task queue) is determined by
        # calculating: ceil(available processors * factor)
        max-pool-size-factor  = 3.0

        # Max number of threads to cap factor-based max number to
        # (if using a  bounded task queue)
        max-pool-size-max = 64

        # Specifies the bounded capacity of the task queue (&lt; 1 == unbounded)
        task-queue-size = -1

        # Specifies which type of task queue will be used, can be &quot;array&quot; or
        # &quot;linked&quot; (default)
        task-queue-type = &quot;linked&quot;

        # Allow core threads to time out
        allow-core-timeout = on
      }

      # How long time the dispatcher will wait for new actors until it shuts down
      shutdown-timeout = 1s

      # Throughput defines the number of messages that are processed in a batch
      # before the thread is returned to the pool. Set to 1 for as fair as possible.
      throughput = 5

      # Throughput deadline for Dispatcher, set to 0 or negative for no deadline
      throughput-deadline-time = 0ms

      # For BalancingDispatcher: If the balancing dispatcher should attempt to
      # schedule idle actors using the same dispatcher when a message comes in,
      # and the dispatchers ExecutorService is not fully busy already.
      attempt-teamwork = on

      # If this dispatcher requires a specific type of mailbox, specify the
      # fully-qualified class name here; the actually created mailbox will
      # be a subtype of this type. The empty string signifies no requirement.
      mailbox-requirement = &quot;&quot;
    }

    default-mailbox {
      # FQCN of the MailboxType. The Class of the FQCN must have a public
      # constructor with
      # (akka.actor.ActorSystem.Settings, com.typesafe.config.Config) parameters.
      mailbox-type = &quot;akka.dispatch.UnboundedMailbox&quot;

      # If the mailbox is bounded then it uses this setting to determine its
      # capacity. The provided value must be positive.
      # NOTICE:
      # Up to version 2.1 the mailbox type was determined based on this setting;
      # this is no longer the case, the type must explicitly be a bounded mailbox.
      mailbox-capacity = 1000

      # If the mailbox is bounded then this is the timeout for enqueueing
      # in case the mailbox is full. Negative values signify infinite
      # timeout, which should be avoided as it bears the risk of dead-lock.
      mailbox-push-timeout-time = 10s

      # For Actor with Stash: The default capacity of the stash.
      # If negative (or zero) then an unbounded stash is used (default)
      # If positive then a bounded stash is used and the capacity is set using
      # the property
      stash-capacity = -1
    }

    mailbox {
      # Mapping between message queue semantics and mailbox configurations.
      # Used by akka.dispatch.RequiresMessageQueue[T] to enforce different
      # mailbox types on actors.
      # If your Actor implements RequiresMessageQueue[T], then when you create
      # an instance of that actor its mailbox type will be decided by looking
      # up a mailbox configuration via T in this mapping
      requirements {
        &quot;akka.dispatch.UnboundedMessageQueueSemantics&quot; =
          akka.actor.mailbox.unbounded-queue-based
        &quot;akka.dispatch.BoundedMessageQueueSemantics&quot; =
          akka.actor.mailbox.bounded-queue-based
        &quot;akka.dispatch.DequeBasedMessageQueueSemantics&quot; =
          akka.actor.mailbox.unbounded-deque-based
        &quot;akka.dispatch.UnboundedDequeBasedMessageQueueSemantics&quot; =
          akka.actor.mailbox.unbounded-deque-based
        &quot;akka.dispatch.BoundedDequeBasedMessageQueueSemantics&quot; =
          akka.actor.mailbox.bounded-deque-based
        &quot;akka.dispatch.MultipleConsumerSemantics&quot; =
          akka.actor.mailbox.unbounded-queue-based
      }

      unbounded-queue-based {
        # FQCN of the MailboxType, The Class of the FQCN must have a public
        # constructor with (akka.actor.ActorSystem.Settings,
        # com.typesafe.config.Config) parameters.
        mailbox-type = &quot;akka.dispatch.UnboundedMailbox&quot;
      }

      bounded-queue-based {
        # FQCN of the MailboxType, The Class of the FQCN must have a public
        # constructor with (akka.actor.ActorSystem.Settings,
        # com.typesafe.config.Config) parameters.
        mailbox-type = &quot;akka.dispatch.BoundedMailbox&quot;
      }

      unbounded-deque-based {
        # FQCN of the MailboxType, The Class of the FQCN must have a public
        # constructor with (akka.actor.ActorSystem.Settings,
        # com.typesafe.config.Config) parameters.
        mailbox-type = &quot;akka.dispatch.UnboundedDequeBasedMailbox&quot;
      }

      bounded-deque-based {
        # FQCN of the MailboxType, The Class of the FQCN must have a public
        # constructor with (akka.actor.ActorSystem.Settings,
        # com.typesafe.config.Config) parameters.
        mailbox-type = &quot;akka.dispatch.BoundedDequeBasedMailbox&quot;
      }
    }

    debug {
      # enable function of Actor.loggable(), which is to log any received message
      # at DEBUG level, see the “Testing Actor Systems” section of the Akka
      # Documentation at http://akka.io/docs
      receive = off

      # enable DEBUG logging of all AutoReceiveMessages (Kill, PoisonPill et.c.)
      autoreceive = off

      # enable DEBUG logging of actor lifecycle changes
      lifecycle = off

      # enable DEBUG logging of all LoggingFSMs for events, transitions and timers
      fsm = off

      # enable DEBUG logging of subscription changes on the eventStream
      event-stream = off

      # enable DEBUG logging of unhandled messages
      unhandled = off

      # enable WARN logging of misconfigured routers
      router-misconfiguration = off
    }

    # Entries for pluggable serializers and their bindings.
    serializers {
      java = &quot;akka.serialization.JavaSerializer&quot;
      bytes = &quot;akka.serialization.ByteArraySerializer&quot;
    }

    # Class to Serializer binding. You only need to specify the name of an
    # interface or abstract base class of the messages. In case of ambiguity it
    # is using the most specific configured class, or giving a warning and
    # choosing the “first” one.
    #
    # To disable one of the default serializers, assign its class to &quot;none&quot;, like
    # &quot;java.io.Serializable&quot; = none
    serialization-bindings {
      &quot;[B&quot; = bytes
      &quot;java.io.Serializable&quot; = java
    }

    # Configuration items which are used by the akka.actor.ActorDSL._ methods
    dsl {
      # Maximum queue size of the actor created by newInbox(); this protects
      # against faulty programs which use select() and consistently miss messages
      inbox-size = 1000

      # Default timeout to assume for operations like Inbox.receive et al
      default-timeout = 5s
    }
  }

  # Used to set the behavior of the scheduler.
  # Changing the default values may change the system behavior drastically so make
  # sure you know what you&#39;re doing! See the Scheduler section of the Akka
  # Documentation for more details.
  scheduler {
    # The LightArrayRevolverScheduler is used as the default scheduler in the
    # system. It does not execute the scheduled tasks on exact time, but on every
    # tick, it will run everything that is (over)due. You can increase or decrease
    # the accuracy of the execution timing by specifying smaller or larger tick
    # duration. If you are scheduling a lot of tasks you should consider increasing
    # the ticks per wheel.
    # Note that it might take up to 1 tick to stop the Timer, so setting the
    # tick-duration to a high value will make shutting down the actor system
    # take longer.
    tick-duration = 10ms

    # The timer uses a circular wheel of buckets to store the timer tasks.
    # This should be set such that the majority of scheduled timeouts (for high
    # scheduling frequency) will be shorter than one rotation of the wheel
    # (ticks-per-wheel * ticks-duration)
    # THIS MUST BE A POWER OF TWO!
    ticks-per-wheel = 512

    # This setting selects the timer implementation which shall be loaded at
    # system start-up. Built-in choices are:
    #  - akka.actor.LightArrayRevolverScheduler
    #  - akka.actor.DefaultScheduler (HWT) DEPRECATED
    # The class given here must implement the akka.actor.Scheduler interface
    # and offer a public constructor which takes three arguments:
    #  1) com.typesafe.config.Config
    #  2) akka.event.LoggingAdapter
    #  3) java.util.concurrent.ThreadFactory
    implementation = akka.actor.LightArrayRevolverScheduler

    # When shutting down the scheduler, there will typically be a thread which
    # needs to be stopped, and this timeout determines how long to wait for
    # that to happen. In case of timeout the shutdown of the actor system will
    # proceed without running possibly still enqueued tasks.
    shutdown-timeout = 5s
  }

  io {

    # By default the select loops run on dedicated threads, hence using a
    # PinnedDispatcher
    pinned-dispatcher {
      type = &quot;PinnedDispatcher&quot;
      executor = &quot;thread-pool-executor&quot;
      thread-pool-executor.allow-core-pool-timeout = off
    }

    tcp {

      # The number of selectors to stripe the served channels over; each of
      # these will use one select loop on the selector-dispatcher.
      nr-of-selectors = 1

      # Maximum number of open channels supported by this TCP module; there is
      # no intrinsic general limit, this setting is meant to enable DoS
      # protection by limiting the number of concurrently connected clients.
      # Also note that this is a &quot;soft&quot; limit; in certain cases the implementation
      # will accept a few connections more or a few less than the number configured
      # here. Must be an integer &gt; 0 or &quot;unlimited&quot;.
      max-channels = 256000

      # When trying to assign a new connection to a selector and the chosen
      # selector is at full capacity, retry selector choosing and assignment
      # this many times before giving up
      selector-association-retries = 10

      # The maximum number of connection that are accepted in one go,
      # higher numbers decrease latency, lower numbers increase fairness on
      # the worker-dispatcher
      batch-accept-limit = 10

      # The number of bytes per direct buffer in the pool used to read or write
      # network data from the kernel.
      direct-buffer-size = 128 KiB

      # The maximal number of direct buffers kept in the direct buffer pool for
      # reuse.
      direct-buffer-pool-limit = 1000

      # The duration a connection actor waits for a `Register` message from
      # its commander before aborting the connection.
      register-timeout = 5s

      # The maximum number of bytes delivered by a `Received` message. Before
      # more data is read from the network the connection actor will try to
      # do other work.
      max-received-message-size = unlimited

      # Enable fine grained logging of what goes on inside the implementation.
      # Be aware that this may log more than once per message sent to the actors
      # of the tcp implementation.
      trace-logging = off

      # Fully qualified config path which holds the dispatcher configuration
      # to be used for running the select() calls in the selectors
      selector-dispatcher = &quot;akka.io.pinned-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # for the read/write worker actors
      worker-dispatcher = &quot;akka.actor.default-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # for the selector management actors
      management-dispatcher = &quot;akka.actor.default-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # on which file IO tasks are scheduled
      file-io-dispatcher = &quot;akka.actor.default-dispatcher&quot;

      # The maximum number of bytes (or &quot;unlimited&quot;) to transfer in one batch
      # when using `WriteFile` command which uses `FileChannel.transferTo` to
      # pipe files to a TCP socket. On some OS like Linux `FileChannel.transferTo`
      # may block for a long time when network IO is faster than file IO.
      # Decreasing the value may improve fairness while increasing may improve
      # throughput.
      file-io-transferTo-limit = 512 KiB

      # The number of times to retry the `finishConnect` call after being notified about
      # OP_CONNECT. Retries are needed if the OP_CONNECT notification doesn&#39;t imply that
      # `finishConnect` will succeed, which is the case on Android.
      finish-connect-retries = 5
    }

    udp {

      # The number of selectors to stripe the served channels over; each of
      # these will use one select loop on the selector-dispatcher.
      nr-of-selectors = 1

      # Maximum number of open channels supported by this UDP module Generally
      # UDP does not require a large number of channels, therefore it is
      # recommended to keep this setting low.
      max-channels = 4096

      # The select loop can be used in two modes:
      # - setting &quot;infinite&quot; will select without a timeout, hogging a thread
      # - setting a positive timeout will do a bounded select call,
      #   enabling sharing of a single thread between multiple selectors
      #   (in this case you will have to use a different configuration for the
      #   selector-dispatcher, e.g. using &quot;type=Dispatcher&quot; with size 1)
      # - setting it to zero means polling, i.e. calling selectNow()
      select-timeout = infinite

      # When trying to assign a new connection to a selector and the chosen
      # selector is at full capacity, retry selector choosing and assignment
      # this many times before giving up
      selector-association-retries = 10

      # The maximum number of datagrams that are read in one go,
      # higher numbers decrease latency, lower numbers increase fairness on
      # the worker-dispatcher
      receive-throughput = 3

      # The number of bytes per direct buffer in the pool used to read or write
      # network data from the kernel.
      direct-buffer-size = 128 KiB

      # The maximal number of direct buffers kept in the direct buffer pool for
      # reuse.
      direct-buffer-pool-limit = 1000

      # The maximum number of bytes delivered by a `Received` message. Before
      # more data is read from the network the connection actor will try to
      # do other work.
      received-message-size-limit = unlimited

      # Enable fine grained logging of what goes on inside the implementation.
      # Be aware that this may log more than once per message sent to the actors
      # of the tcp implementation.
      trace-logging = off

      # Fully qualified config path which holds the dispatcher configuration
      # to be used for running the select() calls in the selectors
      selector-dispatcher = &quot;akka.io.pinned-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # for the read/write worker actors
      worker-dispatcher = &quot;akka.actor.default-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # for the selector management actors
      management-dispatcher = &quot;akka.actor.default-dispatcher&quot;
    }

    udp-connected {

      # The number of selectors to stripe the served channels over; each of
      # these will use one select loop on the selector-dispatcher.
      nr-of-selectors = 1

      # Maximum number of open channels supported by this UDP module Generally
      # UDP does not require a large number of channels, therefore it is
      # recommended to keep this setting low.
      max-channels = 4096

      # The select loop can be used in two modes:
      # - setting &quot;infinite&quot; will select without a timeout, hogging a thread
      # - setting a positive timeout will do a bounded select call,
      #   enabling sharing of a single thread between multiple selectors
      #   (in this case you will have to use a different configuration for the
      #   selector-dispatcher, e.g. using &quot;type=Dispatcher&quot; with size 1)
      # - setting it to zero means polling, i.e. calling selectNow()
      select-timeout = infinite

      # When trying to assign a new connection to a selector and the chosen
      # selector is at full capacity, retry selector choosing and assignment
      # this many times before giving up
      selector-association-retries = 10

      # The maximum number of datagrams that are read in one go,
      # higher numbers decrease latency, lower numbers increase fairness on
      # the worker-dispatcher
      receive-throughput = 3

      # The number of bytes per direct buffer in the pool used to read or write
      # network data from the kernel.
      direct-buffer-size = 128 KiB

      # The maximal number of direct buffers kept in the direct buffer pool for
      # reuse.
      direct-buffer-pool-limit = 1000

      # The maximum number of bytes delivered by a `Received` message. Before
      # more data is read from the network the connection actor will try to
      # do other work.
      received-message-size-limit = unlimited

      # Enable fine grained logging of what goes on inside the implementation.
      # Be aware that this may log more than once per message sent to the actors
      # of the tcp implementation.
      trace-logging = off

      # Fully qualified config path which holds the dispatcher configuration
      # to be used for running the select() calls in the selectors
      selector-dispatcher = &quot;akka.io.pinned-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # for the read/write worker actors
      worker-dispatcher = &quot;akka.actor.default-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # for the selector management actors
      management-dispatcher = &quot;akka.actor.default-dispatcher&quot;
    }


    # IMPORTANT NOTICE:
    #
    # The following settings belong to the deprecated akka.actor.IO
    # implementation and will be removed once that is removed. They are not
    # taken into account by the akka.io.* implementation, which is configured
    # above!

    # In bytes, the size of the shared read buffer. In the span 0b..2GiB.
    #
    read-buffer-size = 8KiB

    # Specifies how many ops are done between every descriptor selection
    select-interval = 100

    # Number of connections that are allowed in the backlog.
    # 0 or negative means that the platform default will be used.
    default-backlog = 1000
  }


}
</pre></div>
</div>
</div>
<div class="section" id="akka-remote">
<h3>akka-remote</h3>
<div class="highlight-none"><div class="highlight"><pre>#####################################
# Akka Remote Reference Config File #
#####################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

# comments about akka.actor settings left out where they are already in akka-
# actor.jar, because otherwise they would be repeated in config rendering.

akka {

  actor {

    serializers {
      akka-containers = &quot;akka.remote.serialization.MessageContainerSerializer&quot;
      proto = &quot;akka.remote.serialization.ProtobufSerializer&quot;
      daemon-create = &quot;akka.remote.serialization.DaemonMsgCreateSerializer&quot;
    }


    serialization-bindings {
      # Since com.google.protobuf.Message does not extend Serializable but
      # GeneratedMessage does, need to use the more specific one here in order
      # to avoid ambiguity
      &quot;akka.actor.SelectionPath&quot; = akka-containers
      &quot;com.google.protobuf.GeneratedMessage&quot; = proto
      &quot;akka.remote.DaemonMsgCreate&quot; = daemon-create
    }

    deployment {

      default {

        # if this is set to a valid remote address, the named actor will be
        # deployed at that node e.g. &quot;akka://sys@host:port&quot;
        remote = &quot;&quot;

        target {

          # A list of hostnames and ports for instantiating the children of a
          # router
          #   The format should be on &quot;akka://sys@host:port&quot;, where:
          #    - sys is the remote actor system name
          #    - hostname can be either hostname or IP address the remote actor
          #      should connect to
          #    - port should be the port for the remote server on the other node
          # The number of actor instances to be spawned is still taken from the
          # nr-of-instances setting as for local routers; the instances will be
          # distributed round-robin among the given nodes.
          nodes = []

        }
      }
    }
  }

  remote {

    ### General settings

    # Timeout after which the startup of the remoting subsystem is considered
    # to be failed. Increase this value if your transport drivers (see the
    # enabled-transports section) need longer time to be loaded.
    startup-timeout = 10 s

    # Timout after which the graceful shutdown of the remoting subsystem is
    # considered to be failed. After the timeout the remoting system is
    # forcefully shut down. Increase this value if your transport drivers
    # (see the enabled-transports section) need longer time to stop properly.
    shutdown-timeout = 10 s

    # Before shutting down the drivers, the remoting subsystem attempts to flush
    # all pending writes. This setting controls the maximum time the remoting is
    # willing to wait before moving on to shut down the drivers.
    flush-wait-on-shutdown = 2 s

    # Reuse inbound connections for outbound messages
    use-passive-connections = on

    # Controls the backoff interval after a refused write is reattempted.
    # (Transports may refuse writes if their internal buffer is full)
    backoff-interval = 0.01 s

    # Acknowledgment timeout of management commands sent to the transport stack.
    command-ack-timeout = 30 s

    # If set to a nonempty string remoting will use the given dispatcher for
    # its internal actors otherwise the default dispatcher is used. Please note
    # that since remoting can load arbitrary 3rd party drivers (see
    # &quot;enabled-transport&quot; and &quot;adapters&quot; entries) it is not guaranteed that
    # every module will respect this setting.
    use-dispatcher = &quot;&quot;

    ### Security settings

    # Enable untrusted mode for full security of server managed actors, prevents
    # system messages to be send by clients, e.g. messages like &#39;Create&#39;,
    # &#39;Suspend&#39;, &#39;Resume&#39;, &#39;Terminate&#39;, &#39;Supervise&#39;, &#39;Link&#39; etc.
    untrusted-mode = off

    # Should the remote server require that its peers share the same
    # secure-cookie (defined in the &#39;remote&#39; section)? Secure cookies are passed
    # between during the initial handshake. Connections are refused if the initial
    # message contains a mismatching cookie or the cookie is missing.
    require-cookie = off

    # Generate your own with the script availbale in
    # &#39;$AKKA_HOME/scripts/generate_config_with_secure_cookie.sh&#39; or using
    # &#39;akka.util.Crypt.generateSecureCookie&#39;
    secure-cookie = &quot;&quot;

    ### Logging

    # If this is &quot;on&quot;, Akka will log all inbound messages at DEBUG level,
    # if off then they are not logged
    log-received-messages = off

    # If this is &quot;on&quot;, Akka will log all outbound messages at DEBUG level,
    # if off then they are not logged
    log-sent-messages = off

    # Sets the log granularity level at which Akka logs remoting events. This setting
    # can take the values OFF, ERROR, WARNING, INFO, DEBUG, or ON. For compatibility
    # reasons the setting &quot;on&quot; will default to &quot;debug&quot; level. Please note that the effective
    # logging level is still determined by the global logging level of the actor system:
    # for example debug level remoting events will be only logged if the system
    # is running with debug level logging.
    # Failures to deserialize received messages also fall under this flag.
    log-remote-lifecycle-events = on

    # Logging of message types with payload size in bytes larger than
    # this value. Maximum detected size per message type is logged once,
    # with an increase threshold of 10%.
    # By default this feature is turned off. Activate it by setting the property to
    # a value in bytes, such as 1000b. Note that for all messages larger than this
    # limit there will be extra performance and scalability cost.
    log-frame-size-exceeding = off

    ### Failure detection and recovery

    # Settings for the Phi accrual failure detector (http://ddg.jaist.ac.jp/pub/HDY+04.pdf
    # [Hayashibara et al]) used by the remoting subsystem to detect failed
    # connections.
    transport-failure-detector {

      # FQCN of the failure detector implementation.
      # It must implement akka.remote.FailureDetector and have
      # a public constructor with a com.typesafe.config.Config and
      # akka.actor.EventStream parameter.
      implementation-class = &quot;akka.remote.PhiAccrualFailureDetector&quot;

      # How often keep-alive heartbeat messages should be sent to each connection.
      heartbeat-interval = 1 s

      # Defines the failure detector threshold.
      # A low threshold is prone to generate many wrong suspicions but ensures
      # a quick detection in the event of a real crash. Conversely, a high
      # threshold generates fewer mistakes but needs more time to detect
      # actual crashes.
      threshold = 7.0

      # Number of the samples of inter-heartbeat arrival times to adaptively
      # calculate the failure timeout for connections.
      max-sample-size = 100

      # Minimum standard deviation to use for the normal distribution in
      # AccrualFailureDetector. Too low standard deviation might result in
      # too much sensitivity for sudden, but normal, deviations in heartbeat
      # inter arrival times.
      min-std-deviation = 100 ms

      # Number of potentially lost/delayed heartbeats that will be
      # accepted before considering it to be an anomaly.
      # This margin is important to be able to survive sudden, occasional,
      # pauses in heartbeat arrivals, due to for example garbage collect or
      # network drop.
      acceptable-heartbeat-pause = 3 s
    }

    # Settings for the Phi accrual failure detector (http://ddg.jaist.ac.jp/pub/HDY+04.pdf
    # [Hayashibara et al]) used for remote death watch.
    watch-failure-detector {

      # FQCN of the failure detector implementation.
      # It must implement akka.remote.FailureDetector and have
      # a public constructor with a com.typesafe.config.Config and
      # akka.actor.EventStream parameter.
      implementation-class = &quot;akka.remote.PhiAccrualFailureDetector&quot;

      # How often keep-alive heartbeat messages should be sent to each connection.
      heartbeat-interval = 1 s

      # Defines the failure detector threshold.
      # A low threshold is prone to generate many wrong suspicions but ensures
      # a quick detection in the event of a real crash. Conversely, a high
      # threshold generates fewer mistakes but needs more time to detect
      # actual crashes.
      threshold = 10.0

      # Number of the samples of inter-heartbeat arrival times to adaptively
      # calculate the failure timeout for connections.
      max-sample-size = 200

      # Minimum standard deviation to use for the normal distribution in
      # AccrualFailureDetector. Too low standard deviation might result in
      # too much sensitivity for sudden, but normal, deviations in heartbeat
      # inter arrival times.
      min-std-deviation = 100 ms

      # Number of potentially lost/delayed heartbeats that will be
      # accepted before considering it to be an anomaly.
      # This margin is important to be able to survive sudden, occasional,
      # pauses in heartbeat arrivals, due to for example garbage collect or
      # network drop.
      acceptable-heartbeat-pause = 4 s


      # How often to check for nodes marked as unreachable by the failure
      # detector
      unreachable-nodes-reaper-interval = 1s

      # After the heartbeat request has been sent the first failure detection
      # will start after this period, even though no heartbeat mesage has
      # been received.
      expected-response-after = 3 s

    }

    # After failed to establish an outbound connection, the remoting will mark the
    # address as failed. This configuration option controls how much time should
    # be elapsed before reattempting a new connection. While the address is
    # gated, all messages sent to the address are delivered to dead-letters.
    # If this setting is 0, the remoting will always immediately reattempt
    # to establish a failed outbound connection and will buffer writes until
    # it succeeds.
    retry-gate-closed-for = 0 s

    # If the retry gate function is disabled (see retry-gate-closed-for) the
    # remoting subsystem will always attempt to reestablish failed outbound
    # connections. The settings below together control the maximum number of
    # reattempts in a given time window. The number of reattempts during
    # a window of &quot;retry-window&quot; will be maximum &quot;maximum-retries-in-window&quot;.
    retry-window = 60 s
    maximum-retries-in-window = 3

    # The length of time to gate an address whose name lookup has failed
    # or has explicitly signalled that it will not accept connections
    # (remote system is shutting down or the requesting system is quarantined).
    # No connection attempts will be made to an address while it remains
    # gated. Any messages sent to a gated address will be directed to dead
    # letters instead. Name lookups are costly, and the time to recovery
    # is typically large, therefore this setting should be a value in the
    # order of seconds or minutes.
    gate-invalid-addresses-for = 60 s

    # This settings controls how long a system will be quarantined after
    # catastrophic communication failures that result in the loss of system
    # messages. Quarantining prevents communication with the remote system
    # of a given UID. This function can be disabled by setting the value
    # to &quot;off&quot;.
    quarantine-systems-for = 60s

    # This setting defines the maximum number of unacknowledged system messages
    # allowed for a remote system. If this limit is reached the remote system is
    # declared to be dead and its UID marked as tainted.
    system-message-buffer-size = 1000

    # This setting defines the maximum idle time after an individual
    # acknowledgement for system messages is sent. System message delivery
    # is guaranteed by explicit acknowledgement messages. These acks are
    # piggybacked on ordinary traffic messages. If no traffic is detected
    # during the time period configured here, the remoting will send out
    # an individual ack.
    system-message-ack-piggyback-timeout = 1 s

    # This setting defines the time after messages that have not been
    # explicitly acknowledged or negatively acknowledged are resent.
    # Messages that were negatively acknowledged are always immediately
    # resent.
    resend-interval = 1 s

    ### Transports and adapters

    # List of the transport drivers that will be loaded by the remoting.
    # A list of fully qualified config paths must be provided where
    # the given configuration path contains a transport-class key
    # pointing to an implementation class of the Transport interface.
    # If multiple transports are provided, the address of the first
    # one will be used as a default address.
    enabled-transports = [&quot;akka.remote.netty.tcp&quot;]

    # Transport drivers can be augmented with adapters by adding their
    # name to the applied-adapters setting in the configuration of a
    # transport. The available adapters should be configured in this
    # section by providing a name, and the fully qualified name of
    # their corresponding implementation. The class given here
    # must implement akka.akka.remote.transport.TransportAdapterProvider
    # and have public constructor without parameters.
    adapters {
      gremlin = &quot;akka.remote.transport.FailureInjectorProvider&quot;
      trttl = &quot;akka.remote.transport.ThrottlerProvider&quot;
    }

    ### Default configuration for the Netty based transport drivers

    netty.tcp {
      # The class given here must implement the akka.remote.transport.Transport
      # interface and offer a public constructor which takes two arguments:
      #  1) akka.actor.ExtendedActorSystem
      #  2) com.typesafe.config.Config
      transport-class = &quot;akka.remote.transport.netty.NettyTransport&quot;

      # Transport drivers can be augmented with adapters by adding their
      # name to the applied-adapters list. The last adapter in the
      # list is the adapter immediately above the driver, while
      # the first one is the top of the stack below the standard
      # Akka protocol
      applied-adapters = []

      transport-protocol = tcp

      # The default remote server port clients should connect to.
      # Default is 2552 (AKKA), use 0 if you want a random available port
      # This port needs to be unique for each actor system on the same machine.
      port = 2552

      # The hostname or ip to bind the remoting to,
      # InetAddress.getLocalHost.getHostAddress is used if empty
      hostname = &quot;&quot;

      # Enables SSL support on this transport
      enable-ssl = false

      # Sets the connectTimeoutMillis of all outbound connections,
      # i.e. how long a connect may take until it is timed out
      connection-timeout = 15 s

      # If set to &quot;&lt;id.of.dispatcher&gt;&quot; then the specified dispatcher
      # will be used to accept inbound connections, and perform IO. If &quot;&quot; then
      # dedicated threads will be used.
      # Please note that the Netty driver only uses this configuration and does
      # not read the &quot;akka.remote.use-dispatcher&quot; entry. Instead it has to be
      # configured manually to point to the same dispatcher if needed.
      use-dispatcher-for-io = &quot;&quot;

      # Sets the high water mark for the in and outbound sockets,
      # set to 0b for platform default
      write-buffer-high-water-mark = 0b

      # Sets the low water mark for the in and outbound sockets,
      # set to 0b for platform default
      write-buffer-low-water-mark = 0b

      # Sets the send buffer size of the Sockets,
      # set to 0b for platform default
      send-buffer-size = 256000b

      # Sets the receive buffer size of the Sockets,
      # set to 0b for platform default
      receive-buffer-size = 256000b

      # Maximum message size the transport will accept, but at least
      # 32000 bytes.
      # Please note that UDP does not support arbitrary large datagrams,
      # so this setting has to be chosen carefully when using UDP.
      # Both send-buffer-size and receive-buffer-size settings has to
      # be adjusted to be able to buffer messages of maximum size.
      maximum-frame-size = 128000b

      # Sets the size of the connection backlog
      backlog = 4096

      # Enables the TCP_NODELAY flag, i.e. disables Nagle’s algorithm
      tcp-nodelay = on

      # Enables TCP Keepalive, subject to the O/S kernel’s configuration
      tcp-keepalive = on

      # Enables SO_REUSEADDR, which determines when an ActorSystem can open
      # the specified listen port (the meaning differs between *nix and Windows)
      # Valid values are &quot;on&quot;, &quot;off&quot; and &quot;off-for-windows&quot;
      # due to the following Windows bug: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4476378
      # &quot;off-for-windows&quot; of course means that it&#39;s &quot;on&quot; for all other platforms
      tcp-reuse-addr = off-for-windows

      # Used to configure the number of I/O worker threads on server sockets
      server-socket-worker-pool {
        # Min number of threads to cap factor-based number to
        pool-size-min = 2

        # The pool size factor is used to determine thread pool size
        # using the following formula: ceil(available processors * factor).
        # Resulting size is then bounded by the pool-size-min and
        # pool-size-max values.
        pool-size-factor = 1.0

        # Max number of threads to cap factor-based number to
        pool-size-max = 2
      }

      # Used to configure the number of I/O worker threads on client sockets
      client-socket-worker-pool {
        # Min number of threads to cap factor-based number to
        pool-size-min = 2

        # The pool size factor is used to determine thread pool size
        # using the following formula: ceil(available processors * factor).
        # Resulting size is then bounded by the pool-size-min and
        # pool-size-max values.
        pool-size-factor = 1.0

        # Max number of threads to cap factor-based number to
        pool-size-max = 2
      }


    }

    netty.udp = ${akka.remote.netty.tcp}
    netty.udp {
      transport-protocol = udp
    }

    netty.ssl = ${akka.remote.netty.tcp}
    netty.ssl = {
      # Enable SSL/TLS encryption.
      # This must be enabled on both the client and server to work.
      enable-ssl = true

      security {
        # This is the Java Key Store used by the server connection
        key-store = &quot;keystore&quot;

        # This password is used for decrypting the key store
        key-store-password = &quot;changeme&quot;

        # This password is used for decrypting the key
        key-password = &quot;changeme&quot;

        # This is the Java Key Store used by the client connection
        trust-store = &quot;truststore&quot;

        # This password is used for decrypting the trust store
        trust-store-password = &quot;changeme&quot;

        # Protocol to use for SSL encryption, choose from:
        # Java 6 &amp; 7:
        #   &#39;SSLv3&#39;, &#39;TLSv1&#39;
        # Java 7:
        #   &#39;TLSv1.1&#39;, &#39;TLSv1.2&#39;
        protocol = &quot;TLSv1&quot;

        # Example: [&quot;TLS_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;]
        # You need to install the JCE Unlimited Strength Jurisdiction Policy
        # Files to use AES 256.
        # More info here:
        # http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJCEProvider
        enabled-algorithms = [&quot;TLS_RSA_WITH_AES_128_CBC_SHA&quot;]

        # There are three options, in increasing order of security:
        # &quot;&quot; or SecureRandom =&gt; (default)
        # &quot;SHA1PRNG&quot; =&gt; Can be slow because of blocking issues on Linux
        # &quot;AES128CounterSecureRNG&quot; =&gt; fastest startup and based on AES encryption
        # algorithm
        # &quot;AES256CounterSecureRNG&quot;
        # The following use one of 3 possible seed sources, depending on
        # availability: /dev/random, random.org and SecureRandom (provided by Java)
        # &quot;AES128CounterInetRNG&quot;
        # &quot;AES256CounterInetRNG&quot; (Install JCE Unlimited Strength Jurisdiction
        # Policy Files first)
        # Setting a value here may require you to supply the appropriate cipher
        # suite (see enabled-algorithms section above)
        random-number-generator = &quot;&quot;
      }
    }

  }

}
</pre></div>
</div>
</div>
<div class="section" id="akka-testkit">
<h3>akka-testkit</h3>
<div class="highlight-none"><div class="highlight"><pre>######################################
# Akka Testkit Reference Config File #
######################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {
  test {
    # factor by which to scale timeouts during tests, e.g. to account for shared
    # build system load
    timefactor =  1.0

    # duration of EventFilter.intercept waits after the block is finished until
    # all required messages are received
    filter-leeway = 3s

    # duration to wait in expectMsg and friends outside of within() block
    # by default
    single-expect-default = 3s

    # The timeout that is added as an implicit by DefaultTimeout trait
    default-timeout = 5s

    calling-thread-dispatcher {
      type = akka.testkit.CallingThreadDispatcherConfigurator
    }
  }
}
</pre></div>
</div>
</div>
<div class="section" id="akka-camel">
<h3>akka-camel</h3>
<div class="highlight-none"><div class="highlight"><pre>####################################
# Akka Camel Reference Config File #
####################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {
  camel {
    # Whether JMX should be enabled or disabled for the Camel Context
    jmx = off
    # enable/disable streaming cache on the Camel Context
    streamingCache = on
    consumer {
      # Configured setting which determines whether one-way communications
      # between an endpoint and this consumer actor
      # should be auto-acknowledged or application-acknowledged.
      # This flag has only effect when exchange is in-only.
      auto-ack = on

      # When endpoint is out-capable (can produce responses) reply-timeout is the
      # maximum time the endpoint can take to send the response before the message
      # exchange fails. This setting is used for out-capable, in-only,
      # manually acknowledged communication.
      reply-timeout = 1m

      # The duration of time to await activation of an endpoint.
      activation-timeout = 10s
    }

    #Scheme to FQCN mappings for CamelMessage body conversions
    conversions {
      &quot;file&quot; = &quot;java.io.InputStream&quot;
    }
  }
}
</pre></div>
</div>
</div>
<div class="section" id="akka-cluster">
<h3>akka-cluster</h3>
<div class="highlight-none"><div class="highlight"><pre>######################################
# Akka Cluster Reference Config File #
######################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {

  cluster {
    # Initial contact points of the cluster.
    # The nodes to join automatically at startup.
    # Comma separated full URIs defined by a string on the form of
    # &quot;akka://system@hostname:port&quot;
    # Leave as empty if the node is supposed to be joined manually.
    seed-nodes = []

    # how long to wait for one of the seed nodes to reply to initial join request
    seed-node-timeout = 5s

    # If a join request fails it will be retried after this period.
    # Disable join retry by specifying &quot;off&quot;.
    retry-unsuccessful-join-after = 10s

    # Should the &#39;leader&#39; in the cluster be allowed to automatically mark
    # unreachable nodes as DOWN?
    # Using auto-down implies that two separate clusters will automatically be
    # formed in case of network partition.
    auto-down = off

    # The roles of this member. List of strings, e.g. roles = [&quot;A&quot;, &quot;B&quot;].
    # The roles are part of the membership information and can be used by
    # routers or other services to distribute work to certain member types,
    # e.g. front-end and back-end nodes.
    roles = []

    role {
      # Minimum required number of members of a certain role before the leader
      # changes member status of &#39;Joining&#39; members to &#39;Up&#39;. Typically used together
      # with &#39;Cluster.registerOnMemberUp&#39; to defer some action, such as starting
      # actors, until the cluster has reached a certain size.
      # E.g. to require 2 nodes with role &#39;frontend&#39; and 3 nodes with role &#39;backend&#39;:
      #   frontend.min-nr-of-members = 2
      #   backend.min-nr-of-members = 3
      #&lt;role-name&gt;.min-nr-of-members = 1
    }

    # Minimum required number of members before the leader changes member status
    # of &#39;Joining&#39; members to &#39;Up&#39;. Typically used together with
    # &#39;Cluster.registerOnMemberUp&#39; to defer some action, such as starting actors,
    # until the cluster has reached a certain size.
    min-nr-of-members = 1

    # Enable/disable info level logging of cluster events
    log-info = on

    # Enable or disable JMX MBeans for management of the cluster
    jmx.enabled = on

    # how long should the node wait before starting the periodic tasks
    # maintenance tasks?
    periodic-tasks-initial-delay = 1s

    # how often should the node send out gossip information?
    gossip-interval = 1s

    # how often should the leader perform maintenance tasks?
    leader-actions-interval = 1s

    # how often should the node move nodes, marked as unreachable by the failure
    # detector, out of the membership ring?
    unreachable-nodes-reaper-interval = 1s

    # How often the current internal stats should be published.
    # A value of 0s can be used to always publish the stats, when it happens.
    # Disable with &quot;off&quot;.
    publish-stats-interval = off

    # The id of the dispatcher to use for cluster actors. If not specified
    # default dispatcher is used.
    # If specified you need to define the settings of the actual dispatcher.
    use-dispatcher = &quot;&quot;

    # Gossip to random node with newer or older state information, if any with
    # this probability. Otherwise Gossip to any random live node.
    # Probability value is between 0.0 and 1.0. 0.0 means never, 1.0 means always.
    gossip-different-view-probability = 0.8

    # Settings for the Phi accrual failure detector (http://ddg.jaist.ac.jp/pub/HDY+04.pdf
    # [Hayashibara et al]) used by the cluster subsystem to detect unreachable
    # members.
    failure-detector {

      # FQCN of the failure detector implementation.
      # It must implement akka.remote.FailureDetector and have
      # a public constructor with a com.typesafe.config.Config and
      # akka.actor.EventStream parameter.
      implementation-class = &quot;akka.remote.PhiAccrualFailureDetector&quot;

      # How often keep-alive heartbeat messages should be sent to each connection.
      heartbeat-interval = 1 s

      # Defines the failure detector threshold.
      # A low threshold is prone to generate many wrong suspicions but ensures
      # a quick detection in the event of a real crash. Conversely, a high
      # threshold generates fewer mistakes but needs more time to detect
      # actual crashes.
      threshold = 8.0

      # Number of the samples of inter-heartbeat arrival times to adaptively
      # calculate the failure timeout for connections.
      max-sample-size = 1000

      # Minimum standard deviation to use for the normal distribution in
      # AccrualFailureDetector. Too low standard deviation might result in
      # too much sensitivity for sudden, but normal, deviations in heartbeat
      # inter arrival times.
      min-std-deviation = 100 ms

      # Number of potentially lost/delayed heartbeats that will be
      # accepted before considering it to be an anomaly.
      # This margin is important to be able to survive sudden, occasional,
      # pauses in heartbeat arrivals, due to for example garbage collect or
      # network drop.
      acceptable-heartbeat-pause = 3 s

      # Number of member nodes that each member will send heartbeat messages to,
      # i.e. each node will be monitored by this number of other nodes.
      monitored-by-nr-of-members = 5

      # When a node stops sending heartbeats to another node it will end that
      # with this number of EndHeartbeat messages, which will remove the
      # monitoring from the failure detector.
      nr-of-end-heartbeats = 8

      # When no expected heartbeat message has been received an explicit
      # heartbeat request is sent to the node that should emit heartbeats.
      heartbeat-request {
        # Grace period until an explicit heartbeat request is sent
        grace-period = 10 s

        # After the heartbeat request has been sent the first failure detection
        # will start after this period, even though no heartbeat mesage has
        # been received.
        expected-response-after = 3 s

        # Cleanup of obsolete heartbeat requests
        time-to-live = 60 s
      }
    }

    metrics {
      # Enable or disable metrics collector for load-balancing nodes.
      enabled = on

      # FQCN of the metrics collector implementation.
      # It must implement akka.cluster.MetricsCollector and
      # have public constructor with akka.actor.ActorSystem parameter.
      # The default SigarMetricsCollector uses JMX and Hyperic SIGAR, if SIGAR
      # is on the classpath, otherwise only JMX.
      collector-class = &quot;akka.cluster.SigarMetricsCollector&quot;

      # How often metrics are sampled on a node.
      # Shorter interval will collect the metrics more often.
      collect-interval = 3s

      # How often a node publishes metrics information.
      gossip-interval = 3s

      # How quickly the exponential weighting of past data is decayed compared to
      # new data. Set lower to increase the bias toward newer values.
      # The relevance of each data sample is halved for every passing half-life
      # duration, i.e. after 4 times the half-life, a data sample’s relevance is
      # reduced to 6% of its original relevance. The initial relevance of a data
      # sample is given by 1 – 0.5 ^ (collect-interval / half-life).
      # See http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
      moving-average-half-life = 12s
    }

    # If the tick-duration of the default scheduler is longer than the
    # tick-duration configured here a dedicated scheduler will be used for
    # periodic tasks of the cluster, otherwise the default scheduler is used.
    # See akka.scheduler settings for more details.
    scheduler {
      tick-duration = 33ms
      ticks-per-wheel = 512
    }

  }

  # Default configuration for routers
  actor.deployment.default {
    # MetricsSelector to use
    # - available: &quot;mix&quot;, &quot;heap&quot;, &quot;cpu&quot;, &quot;load&quot;
    # - or: Fully qualified class name of the MetricsSelector class.
    #       The class must extend akka.cluster.routing.MetricsSelector
    #       and have a public constructor with com.typesafe.config.Config
    #       parameter.
    # - default is &quot;mix&quot;
    metrics-selector = mix
  }
  actor.deployment.default.cluster {
    # enable cluster aware router that deploys to nodes in the cluster
    enabled = off

    # Maximum number of routees that will be deployed on each cluster
    # member node.
    # Note that nr-of-instances defines total number of routees, but
    # number of routees per node will not be exceeded, i.e. if you
    # define nr-of-instances = 50 and max-nr-of-instances-per-node = 2
    # it will deploy 2 routees per new member in the cluster, up to
    # 25 members.
    max-nr-of-instances-per-node = 1

    # Defines if routees are allowed to be located on the same node as
    # the head router actor, or only on remote nodes.
    # Useful for master-worker scenario where all routees are remote.
    allow-local-routees = on

    # Actor path of the routees to lookup with actorFor on the member
    # nodes in the cluster. E.g. &quot;/user/myservice&quot;. If this isn&#39;t defined
    # the routees will be deployed instead of looked up.
    # max-nr-of-instances-per-node should not be configured (default value is 1)
    # when routees-path is defined.
    routees-path = &quot;&quot;

    # Use members with specified role, or all members if undefined or empty.
    use-role = &quot;&quot;

  }

  # Protobuf serializer for cluster messages
  actor {
    serializers {
      akka-cluster = &quot;akka.cluster.protobuf.ClusterMessageSerializer&quot;
    }

    serialization-bindings {
      &quot;akka.cluster.ClusterMessage&quot; = akka-cluster
    }
  }

}
</pre></div>
</div>
</div>
<div class="section" id="akka-transactor">
<h3>akka-transactor</h3>
<div class="highlight-none"><div class="highlight"><pre>#########################################
# Akka Transactor Reference Config File #
#########################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {
  transactor {
    # The timeout used for coordinated transactions across actors
    coordinated-timeout = 5s
  }
}
</pre></div>
</div>
</div>
<div class="section" id="akka-agent">
<h3>akka-agent</h3>
<div class="highlight-none"><div class="highlight"><pre>####################################
# Akka Agent Reference Config File #
####################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {
  agent {

    # The dispatcher used for agent-send-off actor
    send-off-dispatcher {
      executor = thread-pool-executor
      type = PinnedDispatcher
    }

    # The dispatcher used for agent-alter-off actor
    alter-off-dispatcher {
      executor = thread-pool-executor
      type = PinnedDispatcher
    }
  }
}
</pre></div>
</div>
</div>
<div class="section" id="akka-zeromq">
<h3>akka-zeromq</h3>
<div class="highlight-none"><div class="highlight"><pre>#####################################
# Akka ZeroMQ Reference Config File #
#####################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {

  zeromq {

    # The default timeout for a poll on the actual zeromq socket.
    poll-timeout = 100ms

    # Timeout for creating a new socket
    new-socket-timeout = 5s

    socket-dispatcher {
      # A zeromq socket needs to be pinned to the thread that created it.
      # Changing this value results in weird errors and race conditions within
      # zeromq
      executor = thread-pool-executor
      type = &quot;PinnedDispatcher&quot;
      thread-pool-executor.allow-core-timeout = off
    }
  }
}
</pre></div>
</div>
</div>
<div class="section" id="akka-file-mailbox">
<h3>akka-file-mailbox</h3>
<div class="highlight-none"><div class="highlight"><pre>#############################################
# Akka File Mailboxes Reference Config File #
#############################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.
#
# For more information see &lt;https://github.com/robey/kestrel/&gt;

akka {
  actor {
    mailbox {
      file-based {
        # directory below which this queue resides
        directory-path = &quot;./_mb&quot;

        # attempting to add an item after the queue reaches this size (in items)
        # will fail.
        max-items = 2147483647

        # attempting to add an item after the queue reaches this size (in bytes)
        # will fail.
        max-size = 2147483647 bytes

        # attempting to add an item larger than this size (in bytes) will fail.
        max-item-size = 2147483647 bytes

        # maximum expiration time for this queue (seconds).
        max-age = 0s

        # maximum journal size before the journal should be rotated.
        max-journal-size = 16 MiB

        # maximum size of a queue before it drops into read-behind mode.
        max-memory-size = 128 MiB

        # maximum overflow (multiplier) of a journal file before we re-create it.
        max-journal-overflow = 10

        # absolute maximum size of a journal file until we rebuild it,
        # no matter what.
        max-journal-size-absolute = 9223372036854775807 bytes

        # whether to drop older items (instead of newer) when the queue is full
        discard-old-when-full = on

        # whether to keep a journal file at all
        keep-journal = on

        # whether to sync the journal after each transaction
        sync-journal = off

        # circuit breaker configuration
        circuit-breaker {
          # maximum number of failures before opening breaker
          max-failures = 3

          # duration of time beyond which a call is assumed to be timed out and
          # considered a failure
          call-timeout = 3 seconds

          # duration of time to wait until attempting to reset the breaker during
          # which all calls fail-fast
          reset-timeout = 30 seconds
        }
      }
    }
  }
}
</pre></div>
</div>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://akka.io/faq">FAQ</a></li>
      <li><a href="http://typesafe.com/stack/downloads/akka">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>      
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>      
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://typesafe.com/products/typesafe-subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@typesafe.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/watermark.png" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2013 <a href="http://typesafe.com/">Typesafe Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Feb 22, 2014
    </p>          
  </div>
</div>
<script type="text/javascript">
  $('#toc').toc();
</script>
  

  </body>
</html>